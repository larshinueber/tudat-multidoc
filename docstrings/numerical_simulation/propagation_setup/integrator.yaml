extended_summary: |
  This module provides the functionality for creating integrator
  settings.

# The structure of this file follows the order of expose_integrator_setup.cpp (tudatpy) and
# includes content for createNumericalIntegrator.h and bulirschStoerVariableStepsizeIntegrator.h (tudat)


enums:

#######################################################################
  - name: AvailableIntegrators
    short_summary: "Enumeration of integrators available with tudat."

    members:
      - name: runge_kutta_fixed_step_size_type # [py]
      - name: runge_kutta_variable_step_size_type # [py]
      - name: bulirsch_stoer_type # [py]
      - name: adams_bashforth_moulton_type # [py]

#######################################################################

  - name: CoefficientSets
    short_summary: "Coefficient sets for Runge-Kutta-type integrators."
    extended_summary: |
      Coefficient sets for Runge-Kutta-type integrators. The coefficients are defined
      in a Butcher Tableau, with an coefficient set yielding an x(y) method yielding an integrator
      with global truncation error of :math:`O(\Delta t^{x})`. Some of these coefficients also contain an embedded integrator of :math:`O(\Delta t^{y})`
      for step size control.

    members:
      - name: euler_forward # [py]
        description: "Coefficients for the classic forward Euler method" # [py]
      - name: rk_4 # [py]
        description: "Coefficients for the original Runge-Kutta method of order 4" # [py]
      - name: explicit_mid_point # [py]
        description: "Coefficients for the explicit midpoint method" # [py]
      - name: explicit_trapezoid_rule # [py]
        description: "Coefficients for the explicit trapezoid rule, also called Heun's method or improved Euler's method" # [py]
      - name: ralston # [py]
        description: "Coefficients for Ralston's method" # [py]
      - name: rk_3 # [py]
        description: "Coefficients for the Runge-Kutta method of order 3" # [py]
      - name: ralston_3 # [py]
        description: "Coefficients for Ralston's third-order method" # [py]
      - name: SSPRK3 # [py]
        description: "Coefficients for the Strong Stability Preserving Runge-Kutta third-order method" # [py]
      - name: ralston_4 # [py]
        description: "Coefficients for Ralston's fourth-order method" # [py]
      - name: three_eight_rule_rk_4 # [py]
        description: "Coefficients for the classic Runge Kutta 3/8-rule fourth-order method" # [py]
      - name: rkf_12 # [py]
        description: "Coefficients for the Runge-Kutta-Fehlberg method of order 2 with an embedded 1st order" # [py]
      - name: heun_euler # [py]
        description: "Coefficients for the Heun's method of order 2 with an embedded Euler method of order 1" # [py]
      - name: rkf_45 # [py]
        description: "Coefficients for the Runge-Kutta-Fehlberg method of order 5 with an embedded 4th order" # [py]
      - name: rkf_56 # [py]
        description: "Coefficients for the Runge-Kutta-Fehlberg method of order 6 with an embedded 5th order" # [py]
      - name: rkf_78 # [py]
        description: "Coefficients for the Runge-Kutta-Fehlberg method of order 8 with an embedded 7th order" # [py]
      - name: rkdp_87 # [py]
        description: "Coefficients for the Dormand-Prince method of order 7 with an embedded 8th order" # [py]
      - name: rkf_89 # [py]
        description: "Coefficients for the Runge-Kutta-Fehlberg method of order 9 with an embedded 8th order" # [py]
      - name: rkv_89 # [py]
        description: "Coefficients for the Runge-Kutta-Verner method of order 9 with an embedded 8th order" # [py]
      - name: rkf_108 # [py]
        description: "Coefficients for the Runge-Kutta-Feagin method of order 8 with an embedded 10th order" # [py]
      - name: rkf_1210 # [py]
        description: "Coefficients for the Runge-Kutta-Feagin method of order 10 with an embedded 12ve order" # [py]
      - name: rkf_1412 # [py]
        description: "Coefficients for the Runge-Kutta-Feagin method of order 12 with an embedded 14th order" # [py]

#######################################################################

  - name: OrderToIntegrate
    short_summary: "Enumeration defining Which integrator order needs to be integrated, only used for coefficient sets with an embedded order."

    members:
      - name: lower # [py]
        description: For a method of order :math:`p`, with embedded method of order :math:`q`, the step is taken using the method with order :math:`\min(p,q)`
      - name: higher # [py]
        description: For a method of order :math:`p`, with embedded method of order :math:`q`, the step is taken using the method with order :math:`\max(p,q)`
  
  #######################################################################
        
  - name: ExtrapolationMethodStepSequences
    short_summary: "Enumeration of available extrapolation method substep sequences, with :math:`n_{j}` defining the number of substeps in iteration :math:`j`."

    members:
      - name: bulirsch_stoer_sequence
        description: Sequence for which :math:`n_{j}=2n_{j-2}` (2, 4, 6, 8, 12, 16, 24, ....)
      - name: deufelhard_sequence
        description: Sequence for which :math:`n_{j}=2(j+1)` (2, 4, 6, 8, 10, 12, 14, ....)

#######################################################################

  - name: MinimumIntegrationTimeStepHandling
    short_summary: Enumeration defining possible behaviours when :math:`\Delta t_{rec}<\Delta t_{min}`. in step-size control (e.g. recommended time step is smaller than minimum time step)

    members:
      - name: throw_exception_below_minimum
        description: Exception is throw, and propagation is terminated
      - name: set_to_minimum_step_silently
        description: The final time step is set to :math:`\Delta t=\Delta t_{\min}`, violating requirements of step-size control algorithm, without any message to user"

      - name: set_to_minimum_step_single_warning
        description: The final time step is set to :math:`\Delta t=\Delta t_{\min}`, violating requirements of step-size control algorithm, a warning is printed to the terminal the first time this happens during a propagation"
      - name: set_to_minimum_step_every_time_warning
        description: The final time step is set to :math:`\Delta t=\Delta t_{\min}`, violating requirements of step-size control algorithm, a warning is printed to the terminal every time this happens during a propagation"

  #######################################################################
  #######################################################################


classes:

  # base
  - name: IntegratorStepSizeControlSettings
    short_summary: "Base class to define settings for step-size control algorithm."
    extended_summary: |
      Base class to define settings for step-size control algorithm, typically created by one of the factory functions provided in this module
      
#######################################################################


  # base
  - name: IntegratorStepSizeValidationSettings
    short_summary: "Base class to define settings for step-size validation algorithm."
    extended_summary: |
      Base class to define settings for step-size validation algorithm, typically created by one of the factory functions provided in this module
      
#######################################################################

  # base
  - name: IntegratorSettings
    short_summary: "Functional base class to define settings for integrators."
    extended_summary: |
      Class to define settings for numerical integrators, for instance for use in numerical integration of equations of motion/
      variational equations. This class can be used for simple integrators such as fixed step RK and Euler. Integrators that
      require more settings to define have their own derived class.

#    methods:
#      - name: ctor # [cpp]
#        short_summary: "Constructor." # [cpp]
#        extended_summary: "Instances of this class are typically not generated by the user because this is a base class." # [cpp]

#    attributes:
#      - name: initial_time # [py]
#        type: float # [py]
#        description: Initial time of the integration. # [py]


#######################################################################

  # derived (1)
  - name: RungeKuttaFixedStepSizeSettings
    short_summary: "`IntegratorSettings`-derived class to define settings for Runge Kutta integrators with a fixed step size"

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for integrators should be instantiated through the factory functions of a derived class." # [cpp]


#######################################################################

  # derived (2)
  #- name: RungeKuttaVariableStepSizeSettingsScalarTolerances
  #  short_summary: "`IntegratorSettings`-derived class to define settings for Runge Kutta integrators with scalar tolerances."
  #  extended_summary: |
  #    This
  #    class is actually derived from an intermediate class (`RungeKuttaVariableStepSizeBaseSettings`, not documented),
  #    which is derived directly from `IntegratorSettings`.

#    methods:
#      - name: ctor # [cpp]
#        short_summary: "Constructor." # [cpp]
#        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for integrators should be instantiated through the factory functions of a derived class." # [cpp]


  # derived (3)
 # - name: RungeKuttaVariableStepSizeSettingsVectorTolerances
 #   short_summary: "`IntegratorSettings`-derived class to define settings for Runge Kutta integrators with vector tolerances."
 #   extended_summary: |
 #     This class is actually derived from an intermediate class (`RungeKuttaVariableStepSizeBaseSettings`, not documented),
 #     which is derived directly from `IntegratorSettings#`.

 #   methods:
 #     - name: ctor # [cpp]
 #       short_summary: "Constructor." # [cpp]
 #       extended_summary: "Instances of this class are typically not generated by the user. Settings objects for integrators should be instantiated through the factory functions of a derived class." # [cpp]

#######################################################################

  # derived (3)
  - name: BulirschStoerIntegratorSettings
    short_summary: "`IntegratorSettings`-derived class to define settings for Bulirsch-Stoer integrator settings."

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for integrators should be instantiated through the factory functions of a derived class." # [cpp]

#######################################################################

  # derived (4)
  - name: AdamsBashforthMoultonSettings
    short_summary: "`IntegratorSettings`-derived class to define settings for Adams-Bashforth-Moulton integrator settings."

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for integrators should be instantiated through the factory functions of a derived class." # [cpp]


functions:


#######################################################################

  - name: step_size_validation # [py]
    short_summary: "Creates settings step size validation in a variable step-size integrator."
    extended_summary: |
      Factory function to create settings step size validation in a variable step-size integrator. The validation
      model takes the proposed new step size  :math:`\Delta t_{rec}` as input, and checks if it meets predefined conditions, specifically
      whether the proposed time step falls in a given predefined range :math:`[\Delta t_{\min}, \Delta t_{max}]`.
      This function also provides the option of handling recommended step sizes below :math:`\Delta t_{\min}` in various ways,
      and control on how to deal with recommend Inf/NaN step sizes.
    
    parameters:
      - name: minimum_step
        type: float
        description: Value of minimum permitted time step :math:`\Delta t_{\min}`.  
      - name: maximum_step
        type: float
        description: Value of maximum permitted time step :math:`\Delta t_{\max}`.  
      - name: minimum_step_size_handling
        type: MinimumIntegrationTimeStepHandling, default = throw_exception_below_minimum
        description: Entry defining the behaviour when :math:`\Delta t_{rec}<\Delta t_{\min}`.  
      - name: accept_infinity_step
        type: bool, default = False
        description: "Entry defining whether to accept a step size of infinity (if False, exception is throw in such cases)"  
      - name: accept_nan_step
        type: bool, default = False
        description: "Entry defining whether to accept a step size of NaN (if False, exception is throw in such cases)"  
        
    returns:
        type: IntegratorStepSizeValidationSettings # [py]
        description: Object containing settings for step-size validation. # [py]

#######################################################################

  - name: step_size_control_elementwise_scalar_tolerance # [py]
    short_summary: "Creates settings for integrator step-size control, using element-wise analysis for the propagated states."
    extended_summary: |
      Function to create settings for integrator step-size control, using element-wise analysis for the propagated states. For a propagated
      state with :math:`\mathbf{x}` with entries :math:`x_{i}`, and an estimate :math:`\boldsymbol{\epsilon}` for the current local error, the following
      algorithm is performed per element :math:`i` to calculate the required error :math:`\epsilon_{i,req}` on this element:
      
      .. math::
      
         \epsilon_{i,req}=\epsilon_{r}x_{i}+\epsilon_{a}
         
      A proposed modification to the step size is then computed, using the most constraining of all state elements
      
      .. math::
         
         \bar{\Delta t_{rec.}}&=\Delta t\left(\min_{i}\left(\frac{\epsilon_{i,req}}{\epsilon_{i}}\right)\right)^{p}\\
         \Delta t_{rec.}&=K\bar{\Delta t_{rec.}}
    
      with :math:`p` the order of the local truncation error of the method for which step-size control is being applied, 
      :math:`\Delta t_{rec.}` the new, recommended step size, and :math:`\Delta t` the current step size. The factor :math:`K` is a safety factor
      used make the time step slightly smaller than strictly required.
      
      A minimum and maximum change in time step may be provided by the user, such that if :math:`\Delta t_{rec.}/\Delta t` is too large or too small,
      the proposed increase/decrease to the step size is constrained to this limit value. That is, if :math:`\Delta t_{rec.}/\Delta t` proposed by the algorithm is
      1000, and the ``maximum_factor_increase`` input is equal to 20, the algorithm will use :math:`\Delta t_{rec.}/\Delta t=20` in what follows. 
      
      For cases where :math:`\bar{\Delta t_{rec.}}/\Delta t`<1`, the step is recommended to be recomputed with the new proposed step size (e.g. the current step 
      is not accepted, and will be re-attempted with a smaller step size). For cases where :math:`\bar{\Delta t_{rec.}}/\Delta t`>1`, the step is accepted, and 
      the next step will be performed with the new, higher, step size.
      
    parameters:
      - name: relative_error_tolerance
        type: float
        description: Value of relative error tolerance :math:`\epsilon_{r}`.  
      - name: absolute_error_tolerance
        type: float
        description: Value of absolute error tolerance :math:`\epsilon_{a}`.  
      - name: safety_factor
        type: float, default = 0.8
        description: Safety factor :math:`K` for step size control 
      - name: minimum_factor_increase
        type: float, default = 0.1
        description: Minimum permissible value for :math:`\Delta t_{rec.}/\Delta t`  
      - name: maximum_factor_increase
        type: float, default = 4.0
        description: Maximum permissible value for :math:`\Delta t_{rec.}/\Delta t`
        
    returns:
        type: IntegratorStepSizeControlSettings # [py]
        description: Object containing settings for per-element step-size control. # [py]

#######################################################################

  - name: step_size_control_elementwise_matrix_tolerance # [py]
    short_summary: "Creates settings for integrator step-size control, using element-wise analysis for the propagated states."
    extended_summary: |
      Function to create settings for integrator step-size control, using element-wise analysis for the propagated states. This function
      is similar to :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.step_size_control_elementwise_scalar_tolerance`,
      with the differences that the tolerances are provided as a vector/matrix (which must be of equal size as the propagates state), such that
      different tolerances can be provided for each state element. The behaviour of the algorithm is then such that 
      :math:`\epsilon_{r}\rightarrow\epsilon_{r,i}` and :math:`\epsilon_{a}\rightarrow\epsilon_{a,i}`. 
      
      If the size of the tolerances used as input differ from one another, or differ from the size of the state vector, an exception is thrown
      
    parameters:
      - name: relative_error_tolerance
        type: numpy.ndarray[numpy.float64[m, n]]
        description: Values of relative error tolerance :math:`\boldsymbol{\epsilon}_{r}`.  
      - name: absolute_error_tolerance
        type: numpy.ndarray[numpy.float64[m, n]]
        description: Values of absolute error tolerance :math:`\boldsymbol{\epsilon}_{a}`. 
      - name: safety_factor
        type: float, default = 0.8
        description: Safety factor :math:`K` for step size control 
      - name: minimum_factor_increase
        type: float, default = 0.1
        description: Minimum permissible value for :math:`\Delta t_{rec.}/\Delta t`  
      - name: maximum_factor_increase
        type: float, default = 4.0
        description: Maximum permissible value for :math:`\Delta t_{rec.}/\Delta t`
        
    returns:
        type: IntegratorStepSizeControlSettings # [py]
        description: Object containing settings for per-element step-size control. # [py]


#######################################################################


  - name: step_size_control_blockwise_scalar_tolerance # [py]
    short_summary: "Creates settings for integrator step-size control, using block-wise analysis for the propagated states."
    extended_summary: |
      Function to create settings for integrator step-size control, using block-wise analysis for the propagated states. This function
      is similar to :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.step_size_control_elementwise_scalar_tolerance`,
      with the difference that the error estimation :math:`\boldsymbol{\epsilon}` is not used on an element-by-element basis, but using the norms
      of user defined matrix blocks. This is for instance very useful when propagating Cartesian states, where the tolerances are then
      typically applied twice: once to the norm of the position error, and once to the norm of the velocity error.
      
      The algorithm is then run, using the modification 
      that :math:`\epsilon_{i}\rightarrow||\boldsymbol{\epsilon_{[i,k],[j,l]}}||`. Where the indices on the right-hand side denote start row :math:`i`,
      start column :math:`j`, number of rows :math:`k` and number of columns :math:`l`. over
      which the state error norm is to be taken. For a single Cartesian state vector, the norm is taken on blocks :math:`[0,3],[0,1]` and :math:`[3,3],[0,1]`
                  
    parameters:
      - name: block_indices
        type: list[tuple[int,int,int,int]]
        description: List of matrix blocks over which the norms are to be taken (with entries of the tuple denoting :math:`i,j,k,l`, in order.  
      - name: relative_error_tolerance
        type: float
        description: Value of relative error tolerance :math:`\epsilon_{r}`.  
      - name: absolute_error_tolerance
        type: float
        description: Value of absolute error tolerance :math:`\epsilon_{a}`.  
      - name: safety_factor
        type: float, default = 0.8
        description: Safety factor :math:`K` for step size control 
      - name: minimum_factor_increase
        type: float, default = 0.1
        description: Minimum permissible value for :math:`\Delta t_{rec.}/\Delta t`  
      - name: maximum_factor_increase
        type: float, default = 4.0
        description: Maximum permissible value for :math:`\Delta t_{rec.}/\Delta t`
        
    returns:
        type: IntegratorStepSizeControlSettings # [py]
        description: Object containing settings for per-element step-size control. # [py]


#######################################################################

  - name: step_size_control_blockwise_matrix_tolerance # [py]
    short_summary: "Creates settings for integrator step-size control, using block-wise analysis for the propagated states."
    extended_summary: |
      Function to create settings for integrator step-size control, using block-wise analysis for the propagated states. This function
      is similar to :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.step_size_control_blockwise_scalar_tolerance`,
      with the differences that the tolerances are provided as a list (which must be of equal size as the number of state blocks used), such that
      different tolerances can be provided for each state block. 
      
      If the size of the tolerances used as input differ from one another, or differ from the number of blocks, an exception is thrown
                  
    parameters:
      - name: block_indices
        type: list[tuple[int,int,int,int]]
        description: List of matrix blocks over which the norms are to be taken (with entries of the tuple denoting :math:`i,j,k,l`, in order.  
      - name: relative_error_tolerance
        type: numpy.ndarray[numpy.float64[m, 1]]
        description: Values of relative error tolerance :math:`\boldsymbol{\epsilon}_{r}`.  
      - name: absolute_error_tolerance
        type: numpy.ndarray[numpy.float64[m, 1]]
        description: Values of absolute error tolerance :math:`\boldsymbol{\epsilon}_{a}`.  
      - name: safety_factor
        type: float, default = 0.8
        description: Safety factor :math:`K` for step size control 
      - name: minimum_factor_increase
        type: float, default = 0.1
        description: Minimum permissible value for :math:`\Delta t_{rec.}/\Delta t`  
      - name: maximum_factor_increase
        type: float, default = 4.0
        description: Maximum permissible value for :math:`\Delta t_{rec.}/\Delta t`
        
    returns:
        type: IntegratorStepSizeControlSettings # [py]
        description: Object containing settings for per-element step-size control. # [py]
      
  
#######################################################################
      
  - name: step_size_control_custom_blockwise_scalar_tolerance # [py]
    short_summary: "Creates settings for integrator step-size control, using block-wise analysis for the propagated states."
    extended_summary: |
      Function to create settings for integrator step-size control, using block-wise analysis for the propagated states. This function
      is similar to :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.step_size_control_blockwise_scalar_tolerance`,
      but rather than providing the ``block_indices`` directly, a function to determine the block indices, based on the size of the 
      propagated state, is provided. For instance, the :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.standard_cartesian_state_element_blocks`
      can be provided to this function (as ``block_indices_function``), which will adapt the block indices depending on the size of the propagated state
      (e.g. regardless of how many bodies are propagated, step size control will always be done on position and velocity element blocks)  

                  
    parameters:
      - name: block_indices_function
        type: Callable[[int,int],list[tuple[int,int,int,int]]]
        description: Function returning list of matrix blocks over which the norms are to be taken (with entries of the tuple denoting :math:`i,j,k,l`, in order, with number of rows and columns of propagated state as input.
      - name: relative_error_tolerance
        type: float
        description: Value of relative error tolerance :math:`\epsilon_{r}`.  
      - name: absolute_error_tolerance
        type: float
        description: Value of absolute error tolerance :math:`\epsilon_{a}`.  
      - name: safety_factor
        type: float, default = 0.8
        description: Safety factor :math:`K` for step size control 
      - name: minimum_factor_increase
        type: float, default = 0.1
        description: Minimum permissible value for :math:`\Delta t_{rec.}/\Delta t`  
      - name: maximum_factor_increase
        type: float, default = 4.0
        description: Maximum permissible value for :math:`\Delta t_{rec.}/\Delta t`
        
    returns:
        type: IntegratorStepSizeControlSettings # [py]
        description: Object containing settings for per-element step-size control. # [py]

#######################################################################

        
  - name: step_size_control_custom_blockwise_matrix_tolerance # [py]
    short_summary: "Creates settings for integrator step-size control, using block-wise analysis for the propagated states."
    extended_summary: |
      Function to create settings for integrator step-size control, using block-wise analysis for the propagated states. This function
      is similar to :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.step_size_control_custom_blockwise_scalar_tolerance`,
      but uses blockwise tolerances (as in :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.step_size_control_blockwise_matrix_tolerance`)     
                 
    parameters:
      - name: block_indices_function
        type: Callable[[int,int],list[tuple[int,int,int,int]]]
        description: Function returning list of matrix blocks over which the norms are to be taken (with entries of the tuple denoting :math:`i,j,k,l`, in order, with number of rows and columns of propagated state as input.
      - name: relative_error_tolerance
        type: numpy.ndarray[numpy.float64[m, 1]]
        description: Values of relative error tolerance :math:`\boldsymbol{\epsilon}_{r}`.  
      - name: absolute_error_tolerance
        type: numpy.ndarray[numpy.float64[m, 1]]
        description: Values of absolute error tolerance :math:`\boldsymbol{\epsilon}_{a}`.  
      - name: safety_factor
        type: float, default = 0.8
        description: Safety factor :math:`K` for step size control 
      - name: minimum_factor_increase
        type: float, default = 0.1
        description: Minimum permissible value for :math:`\Delta t_{rec.}/\Delta t`  
      - name: maximum_factor_increase
        type: float, default = 4.0
        description: Maximum permissible value for :math:`\Delta t_{rec.}/\Delta t`
        
    returns:
        type: IntegratorStepSizeControlSettings # [py]
        description: Object containing settings for per-element step-size control. # [py]

  #######################################################################


  - name: standard_cartesian_state_element_blocks # [py]
    short_summary: "Function to generate step size control blocks on position and velocity elements for numerical integration"
    extended_summary: |
      Function to generate step size control blocks on position and velocity elements for numerical integration, typically provided
      to the :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.step_size_control_custom_blockwise_scalar_tolerance` or
      :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.step_size_control_custom_blockwise_matrix_tolerance` function.
      By providing this function to one of these step-size control functions, the final column of the state vector is taken (such that
      it works  both for state-only, and variational equations and state propagation) and combined into :math:`N` blocks of size 3.
      The step-size control is then done on each of these blocks, which will represent the position and velocity blocks.

    parameters:
      - name: number_of_rows
        type: int
        description: Number of rows in state vector
      - name: number_of_columns
        type: int
        description: Number of columns in state vector

    returns:
      type: list[tuple[int,int,int,int]] # [py]
      description: List of matrix blocks over which the step size control is to be done (see ``block_indices_function`` input to :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.step_size_control_custom_blockwise_scalar_tolerance`)

        #######################################################################
           
  # Runge Kutta fixed step size
  - name: runge_kutta_fixed_step # [py]
  - name: rungeKuttaFixedStepSettings # [cpp]
    short_summary: "Creates the settings for the Runge-Kutta fixed step size integrator."
    extended_summary: |
      Factory function to create settings for the Runge-Kutta integrator with a constant step size.
      Different coefficient sets (Butcher's tableau) can be used (see the `CoefficientSets` enum).

    parameters:

      - name: time_step # [py]
        type: float # [py]
      - name: initialTimeStep # [cpp]
        type: double # [cpp]
        description: "Initial time step to be used."

      - name: coefficient_set # [py]
        type: CoefficientSets # [py]
      - name: coefficientSet # [cpp]
        type: CoefficientSets # [cpp]
        description: "Coefficient set (Butcher's tableau) to be used in the integration."

      - name: order_to_use # [py]
        type: OrderToIntegrate, default=OrderToIntegrate.lower # [py]
      - name: orderToUse # [cpp]
        type: OrderToIntegrate, default=OrderToIntegrate.lower # [cpp]
        description: |
          If the coefficient set is supposed to be for variable step sizes (with an embedded method of a different order),
          this parameter can be used to set the order that will be used.

      - name: assess_termination_on_minor_steps # [py]
        type: bool, default=false # [py]
      - name: assessTerminationOnMinorSteps # [cpp]
        type: bool, default=false # [cpp]
        description: |
          Whether the propagation termination conditions should be evaluated during the intermediate sub-steps of the
          integrator (true) or only at the end of each integration step (false).

    examples: |
      In this example, settings for the classical RK4 integrator with 30 second time step are created

      .. code-block:: python

        # Create RK4 settings
        integrator_settings = integrator.runge_kutta_fixed_step(
            time_step = 30.0,
            coefficient_set = integrator.rk_4 )
      
      In this example, settings for fixed-step integration using the higher-order (8th-order) of the two
      embedded propagators of the RKF7(8) method are created, with a time-step of 120 seconds.

      .. code-block:: python

        # Create 8th order RKF settings
        integrator_settings = integrator.runge_kutta_fixed_step(
            time_step = 120.0,
            coefficient_set = integrator.rkf_78,
            order_to_use = integrator.higher )      
        
    returns:
        type: IntegratorSettings # [py]
        description: Object containing settings for the integrator. # [py]
        
#######################################################################
           
  # Runge Kutta fixed step size
  - name: runge_kutta_variable_step # [py]
  - name: rungeKuttaFixedStepSettings # [cpp]
    short_summary: "Creates the settings for the Runge-Kutta fixed step size integrator."
    extended_summary: |
      Factory function to create settings for the Runge-Kutta variable step size integrator.
      Different coefficient sets (Butcher's tableau) can be used (see the `CoefficientSets` enum).
      The step-size control algorithm is defined by a :class:`~tudatpy.numerical_simulation.propagation_setup.integrator.IntegratorStepSizeControlSettings` and
      :class:`~tudatpy.numerical_simulation.propagation_setup.integrator.IntegratorStepSizeValidationSettings` object, created using one of the factory functions
      listed above.


    parameters:

      - name: initial_time_step # [py]
        type: float # [py]
      - name: initialTimeStep # [cpp]          
      - name: assessTerminationOnMinorSteps # [cpp]
        type: double # [cpp]
        description: "Initial time step to be used."

      - name: coefficient_set # [py]
        type: CoefficientSets # [py]
      - name: coefficientSet # [cpp]
        type: CoefficientSets # [cpp]
        description: "Coefficient set (Butcher's tableau) to be used in the integration."

      - name: step_size_control_settings # [py]
        type: IntegratorStepSizeControlSettings # [py]
        description: |
          Object used to control the step size, by computing a new step size :math:`\Delta t_{rec.}`, from the embedded Runge-Kutta integrator pair,
          and recommending whether the steps is to be accepted, or recomputed with a different time step.

      - name: step_size_validation_settings # [py]
        type: IntegratorStepSizeValidationSettings # [py]
        description: |
          Object used to validate whether the :math:`\Delta t_{rec.}` provided by model defined by the ``step_size_control_settings`` meets with user-defined
          criteria (minimum, maximum values, etc.)
          
      - name: assess_termination_on_minor_steps # [py]
        type: bool, default=false # [py]
      - name: assessTerminationOnMinorSteps # [cpp]
        type: bool, default=false # [cpp]
        description: |
          Whether the propagation termination conditions should be evaluated during the intermediate sub-steps of the
          integrator (true) or only at the end of each integration step (false).

    examples: |
      In this example, settings for the varianle step RK4(5) integrator are created, with the same tolerances (:math:`10^{-10}`)
      applied element-wise on the propagated state. The minimum and maximum time steps are set to 0.001 and 1000 seconds,
      and the initial step is set to 30 seconds. All other inputs are left on their defaults

      .. code-block:: python

        # Create RK4(5) settings
        control_settings = integator.step_size_control_elementwise_scalar_tolerance( 1.0E-10, 1.0E-10 )
        validation_settings = integrator.step_size_validation( 0.001, 1000.0 )
        integrator_settings = integrator.runge_kutta_variable_step(
            initial_time_step = 30.0,
            coefficient_set = integrator.rkf_45,
            step_size_control_settings = control_settings,
            step_size_validation_settings = validation_settings )
      
      In this example, the above is modified such that step-size control is applied on position and velocity
      element blocks.

      .. code-block:: python

        # Create RK4(5) settings
        control_settings = integator.step_size_control_custom_blockwise_scalar_tolerance( 
            integrator.standard_cartesian_state_element_blocks
            1.0E-10, 1.0E-10 )
        validation_settings = integrator.step_size_validation( 0.001, 1000.0 )
        integrator_settings = integrator.runge_kutta_variable_step(
            initial_time_step = 30.0,
            coefficient_set = integrator.rkf_45,
            step_size_control_settings = control_settings,
            step_size_validation_settings = validation_settings )
    

    returns:
        type: IntegratorSettings # [py]
        description: Object containing settings for the integrator. # [py]


  #######################################################################

  # Bulirsch-Stoer integrator
  - name: bulirsch_stoer_fixed_step # [py]
    short_summary: "Creates the settings for the fixed time-step Bulirsch-Stoer integrator."
    extended_summary: |
      Factory function to create settings for the fixed time-step Bulirsch-Stoer integrator. The
      underlying method is the same as :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.bulirsch_stoer_variable_step`, 
      but using a fixed, user-defined, time step.

    parameters:
      - name: initialTimeStep # [cpp]
        type: double # [cpp]
      - name: time_step # [py]
        type: float # [py]
        description: Time step to be used.

      - name: extrapolationSequence # [cpp]
        type: ExtrapolationMethodStepSequences # [cpp]
      - name: extrapolation_sequence # [py]
        type: ExtrapolationMethodStepSequences # [py]
        description: Extrapolation sequence to be used for the integration (defining the number of substeps in iteration :math:`i`).

      - name: maximumNumberOfSteps # [cpp]
        type: int # [cpp]
      - name: maximum_number_of_steps # [py]
        type: int # [py]
        description: Number of entries from the sequence to be used (e.g., total number of iterations used for a single extrapolation and time step).

      - name: assessTerminationOnMinorSteps # [cpp]
        type: bool, default=false # [cpp]
      - name: assess_termination_on_minor_steps # [py]
        type: bool, default=false # [py]
        description: Whether the propagation termination conditions should be evaluated during the intermediate sub-steps of the integrator (true) or only at the end of each integration step (false).

    examples: |
      In this example, settings for the Bulirsch-Stoer integrator with 600 second time step are created, using the typical
      sequence, using 6 iterations of the same step. By using the Bulirsch-Stoer sequence, this means that the same step is done
      using 2, 4, 6, 8, 12 and 16 substeps     
      
      .. code-block:: python
      
        # Create BS settings
        integrator_settings = integrator.bulirsch_stoer_fixed_step(
            time_step = 300.0,
            extrapolation_sequence = integrator.bulirsch_stoer_sequence,
            maximum_number_of_steps = 6 )

    returns:
      type: IntegratorSettings # [py]
      description: Object containing settings for the integrator. # [py]

  #######################################################################

# Bulirsch-Stoer integrator
  - name: bulirsch_stoer_variable_step # [py]
    short_summary: "Creates the settings for the variable time-step Bulirsch-Stoer integrator."
    extended_summary: |
      Factory function to create settings for the variable time-step Bulirsch-Stoer integrator. This integrator
      works by performing the same (typically very large) step multiple times, using an ever increasing number of substeps.
      Each substep is performed using the modified midpoint method. The succesive integrations from :math:`t_{i}` to :math:`t_{i}+\Delta t`
      are (in principle) done using ever increasing accuracy, as the size of the substep decreases. This integrator works
      by extrapolating the behaviour to a substep length of 0 (e.g. an infinite number of substeps), at which the solution should be perfect.
      The number of substeps on the :math:`i^{t}` iteration are done using the number of substeps defined by  entry :math:`i` of the
      ``extrapolation_sequence`` input. The number of iterations for a single step is defined by the ``maximum_number_of_steps`` entry.
      For instance, using the ``bulirsch_stoer_sequence`` sequence, and 5 iterations, the same step is done using 2, 4, 6, 8 and 12 substeps,
      and the results are then extrapolated to an infinite number of steps. Different extrapolation sequences can be used (see the `ExtrapolationMethodStepSequences` enum).
      
      The step-size control algorithm is defined by a :class:`~tudatpy.numerical_simulation.propagation_setup.integrator.IntegratorStepSizeControlSettings` and
      :class:`~tudatpy.numerical_simulation.propagation_setup.integrator.IntegratorStepSizeValidationSettings` object, created using one of the factory functions
      listed above. The time step control uses the result from the final, and second to final iteration to generate an error estimate of the current step.

    parameters:
      - name: initialTimeStep # [cpp]
        type: double # [cpp]
      - name: time_step # [py]
        type: float # [py]
        description: Initial time step to be used.

      - name: extrapolationSequence # [cpp]
        type: ExtrapolationMethodStepSequences # [cpp]
      - name: extrapolation_sequence # [py]
        type: ExtrapolationMethodStepSequences # [py]
        description: Extrapolation sequence to be used for the integration (defining the number of substeps in iteration :math:`i`).

      - name: maximumNumberOfSteps # [cpp]
        type: int # [cpp]
      - name: maximum_number_of_steps # [py]
        type: int # [py]
        description: Number of entries from the sequence to be used (e.g., total number of iterations used for a single extrapolation and time step).

      - name: step_size_control_settings # [py]
        type: IntegratorStepSizeControlSettings # [py]
        description: |
          Object used to control the step size, by computing a new step size :math:`\Delta t_{rec.}`, from the embedded Runge-Kutta integrator pair,
          and recommending whether the steps is to be accepted, or recomputed with a different time step.

      - name: step_size_validation_settings # [py]
        type: IntegratorStepSizeValidationSettings # [py]
        description: |
          Object used to validate whether the :math:`\Delta t_{rec.}` provided by model defined by the ``step_size_control_settings`` meets with user-defined
          criteria (minimum, maximum values, etc.)
          
      - name: assessTerminationOnMinorSteps # [cpp]
        type: bool, default=false # [cpp]
      - name: assess_termination_on_minor_steps # [py]
        type: bool, default=false # [py]
        description: Whether the propagation termination conditions should be evaluated during the intermediate sub-steps of the integrator (true) or only at the end of each integration step (false).

    examples: |
      In this example, settings for the Bulirsch-Stoer integrator with 600 second initial time step are created, using the typical
      sequence, using 6 iterations of the same step. By using the Bulirsch-Stoer sequence, this means that the same step is done
      using 2, 4, 6, 8, 12 and 16 substeps. The same tolerances (:math:`10^{-10}`)
      applied element-wise on the propagated state. The minimum and maximum time steps are set to 0.1 and 10000 seconds,
      and the initial step is set to 600 seconds. All other inputs are left on their defaults

      .. code-block:: python

        # Create BS settings
        control_settings = integator.step_size_control_elementwise_scalar_tolerance( 1.0E-10, 1.0E-10 )
        validation_settings = integrator.step_size_validation( 0.1, 10000.0 )
        integrator_settings = integrator.bulirsch_stoer_variable_step(
            initial_time_step = 600.0,
            extrapolation_sequence = integrator.bulirsch_stoer_sequence,
            maximum_number_of_steps = 6 
            step_size_control_settings = control_settings,
            step_size_validation_settings = validation_settings )

    returns:
        type: IntegratorSettings # [py]
        description: Object containing settings for the integrator. # [py]

#######################################################################
        
 # Adams-Bashforth-Moulton integrator
  - name: adamsBashforthMoultonSettings # [cpp]
  - name: adams_bashforth_moulton # [py]
    short_summary: "Creates the settings for the Adams-Bashforth-Moulton integrator."
    extended_summary: |
      Factory function to create settings for the Adams-Bashforth-Moulton multistep integrator.
      For this integrator, the step size and order are both according to a control algorithm
      similar to :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.step_size_control_elementwise_scalar_tolerance`.      
      The integrator is initialized using an RKF7(8) integrator.
      
      NOTE: this integrator's step-size and order control algorithm work in a method that is overly simplistic,
      when increasing/decreasing the order, existing function evaluations are re-used, without any recomputations.
      Similarly, when halving or doubling the time-step, the existing interpolating polynomial is evaluated at the relevant points.
      This can lead to unwanted behaviour, where the time-step reduces to unrealistically low values. It is strongly
      recommended that a reasonable minimum step is provided to this function, to partially mitigate this behaviour.

    parameters:
      - name: initialTimeStep # [cpp]
        type: double # [cpp]
      - name: initial_time_step # [py]
        type: float # [py]
        description: Initial time step to be used.

      - name: minimumStepSize # [cpp]
        type: double # [cpp]
      - name: minimum_step_size # [py]
        type: float # [py]
        description: Minimum time step to be used during the integration.

      - name: maximumStepSize # [cpp]
        type: double # [cpp]
      - name: maximum_step_size # [py]
        type: float # [py]
        description: Maximum time step to be used during the integration.

      - name: relativeErrorTolerance # [cpp]
        type: double, default=1.0E-12 # [cpp]
      - name: relative_error_tolerance # [py]
        type: float, default=1.0E-12 # [py]
        description: Relative tolerance to adjust the time step.

      - name: absoluteErrorTolerance # [cpp]
        type: double, default=1.0E-12 # [cpp]
      - name: absolute_error_tolerance # [py]
        type: float, default=1.0E-12 # [py]
        description: Relative tolerance to adjust the time step.

      - name: minimumOrder # [cpp]
        type: int, default=6 # [cpp]
      - name: minimum_order # [py]
        type: int, default=6 # [cpp]
        description: Minimum order of the integrator.

      - name: maximumOrder # [cpp]
        type: int, default=11 # [cpp]
      - name: maximum_order # [py]
        type: int, default=11 # [cpp]
        description: Maximum order of the integrator.

      - name: assessTerminationOnMinorSteps # [cpp]
        type: bool, default=false # [cpp]
      - name: assess_termination_on_minor_steps # [py]
        type: bool, default=false # [py]
        description: Whether the propagation termination conditions should be evaluated during the intermediate sub-steps of the integrator (true) or only at the end of each integration step (false).

      - name: bandwidth # [cpp]
        type: double, default=200.0 # [cpp]
      - name: bandwidth # [py]
        type: float, default=200.0 # [py]
        description: Maximum error factor for doubling the step size.

    returns:
        type: IntegratorSettings # [py]
        description: Object containing settings for the integrator. # [py]


#######################################################################

# Adams-Bashforth-Moulton integrator
  - name: adamsBashforthMoultonSettings # [cpp]
  - name: adams_bashforth_moulton_fixed_order # [py]
    short_summary: "Creates the settings for the Adams-Bashforth-Moulton integrator of fixed order."
    extended_summary: |
      Same as :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.adams_bashforth_moulton`, but
      with fixed order and variable step

    parameters:
      - name: initialTimeStep # [cpp]
        type: double # [cpp]
      - name: initial_time_step # [py]
        type: float # [py]
        description: Initial time step to be used.

      - name: minimumStepSize # [cpp]
        type: double # [cpp]
      - name: minimum_step_size # [py]
        type: float # [py]
        description: Minimum time step to be used during the integration.

      - name: maximumStepSize # [cpp]
        type: double # [cpp]
      - name: maximum_step_size # [py]
        type: float # [py]
        description: Maximum time step to be used during the integration.

      - name: relativeErrorTolerance # [cpp]
        type: double, default=1.0E-12 # [cpp]
      - name: relative_error_tolerance # [py]
        type: float, default=1.0E-12 # [py]
        description: Relative tolerance to adjust the time step.

      - name: absoluteErrorTolerance # [cpp]
        type: double, default=1.0E-12 # [cpp]
      - name: absolute_error_tolerance # [py]
        type: float, default=1.0E-12 # [py]
        description: Relative tolerance to adjust the time step.

      - name: minimumOrder # [cpp]
        type: int, default=6 # [cpp]
      - name: order # [py]
        type: int, default=6 # [cpp]
        description: Order of the integrator.

      - name: assessTerminationOnMinorSteps # [cpp]
        type: bool, default=false # [cpp]
      - name: assess_termination_on_minor_steps # [py]
        type: bool, default=false # [py]
        description: Whether the propagation termination conditions should be evaluated during the intermediate sub-steps of the integrator (true) or only at the end of each integration step (false).

      - name: bandwidth # [cpp]
        type: double, default=200.0 # [cpp]
      - name: bandwidth # [py]
        type: float, default=200.0 # [py]
        description: Maximum error factor for doubling the step size.

    returns:
        type: IntegratorSettings # [py]
        description: Object containing settings for the integrator. # [py]

#######################################################################
        
 # Adams-Bashforth-Moulton integrator
  - name: adamsBashforthMoultonSettings # [cpp]
  - name: adams_bashforth_moulton_fixed_step # [py]
    short_summary: "Creates the settings for the Adams-Bashforth-Moulton fixed-step integrator."
    extended_summary: |
      Same as :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.adams_bashforth_moulton`, but
      with fixed step and variable order

    parameters:
      - name: initialTimeStep # [cpp]
        type: double # [cpp]
      - name: time_step # [py]
        type: float # [py]
        description: Initial time step to be used.

      - name: relativeErrorTolerance # [cpp]
        type: double, default=1.0E-12 # [cpp]
      - name: relative_error_tolerance # [py]
        type: float, default=1.0E-12 # [py]
        description: Relative tolerance to adjust the time step.

      - name: absoluteErrorTolerance # [cpp]
        type: double, default=1.0E-12 # [cpp]
      - name: absolute_error_tolerance # [py]
        type: float, default=1.0E-12 # [py]
        description: Relative tolerance to adjust the time step.

      - name: minimumOrder # [cpp]
        type: int, default=6 # [cpp]
      - name: minimum_order # [py]
        type: int, default=6 # [cpp]
        description: Minimum order of the integrator.

      - name: maximumOrder # [cpp]
        type: int, default=11 # [cpp]
      - name: maximum_order # [py]
        type: int, default=11 # [cpp]
        description: Maximum order of the integrator.

      - name: assessTerminationOnMinorSteps # [cpp]
        type: bool, default=false # [cpp]
      - name: assess_termination_on_minor_steps # [py]
        type: bool, default=false # [py]
        description: Whether the propagation termination conditions should be evaluated during the intermediate sub-steps of the integrator (true) or only at the end of each integration step (false).

      - name: bandwidth # [cpp]
        type: double, default=200.0 # [cpp]
      - name: bandwidth # [py]
        type: float, default=200.0 # [py]
        description: Maximum error factor for doubling the step size.

    returns:
        type: IntegratorSettings # [py]
        description: Object containing settings for the integrator. # [py]

#######################################################################
        
 # Adams-Bashforth-Moulton integrator
  - name: adamsBashforthMoultonSettings # [cpp]
  - name: adams_bashforth_moulton_fixed_step_fixed_order # [py]
    short_summary: "Creates the settings for the Adams-Bashforth-Moulton fixed-step, fixed-order integrator."
    extended_summary: |
      Same as :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.adams_bashforth_moulton`, but
      with fixed step and fixed order

    parameters:
      - name: time_step # [py]
        type: float # [py]
        description: Initial time step to be used.

      - name: minimumOrder # [cpp]
        type: int, default=6 # [cpp]
      - name: order # [py]
        type: int, default=6 # [cpp]
        description: Order of the integrator.
        
      - name: assessTerminationOnMinorSteps # [cpp]
        type: bool, default=false # [cpp]
      - name: assess_termination_on_minor_steps # [py]
        type: bool, default=false # [py]
        description: Whether the propagation termination conditions should be evaluated during the intermediate sub-steps of the integrator (true) or only at the end of each integration step (false).


    returns:
        type: IntegratorSettings # [py]
        description: Object containing settings for the integrator. # [py]
#######################################################################
  # Print Butcher's tableau
  - name: print_butcher_tableau # [py]
  - name: printButcherTableau # [cpp]
    short_summary: "Print the Butcher tableau of a given coefficient set."

    parameters:
      - name: coefficient_set # [py]
        type: CoefficientSets # [py]
      - name: coefficientSet # [cpp]
        type: CoefficientSets # [cpp]
        description: "Coefficient set of which the Butcher tableau will be printed."
        
#######################################################################
  # Runge Kutta variable step size with scalar tolerances (cpp)
  - name: runge_kutta_variable_step_size # [py]
  - name: rungeKuttaVariableStepSettingsScalarTolerances # [cpp]
    short_summary: "Creates the settings for the Runge-Kutta variable step size integrator with scalar tolerances."
    extended_summary: |
      NOTE: THIS FUNCTION IS DEPRECATED, IT IS RECOMMENDED TO USE THE NEW :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.runge_kutta_variable_step` INTERFACE INSTEAD
          
      Factory function to create settings for the Runge-Kutta variable step size integrator with scalar tolerances.
      For this integrator, the step size is varied based on the tolerances and safety factor provided.
      The tolerance is composed of an absolute and a relative part.
      Different coefficient sets (Butcher's tableau) can be used (see the `CoefficientSets` enum).

    parameters:

      - name: initial_time_step # [py]
        type: float # [py]
      - name: initialTimeStep # [cpp]
        type: double # [cpp]
        description: "Initial time step to be used."

      - name: coefficient_set # [py]
        type: CoefficientSets # [py]
      - name: coefficientSet # [cpp]
        type: CoefficientSets # [cpp]
        description: "Coefficient set (Butcher's tableau) to be used in the integration."

      - name: minimum_step_size # [py]
        type: float # [py]
      - name: minimumStepSize # [cpp]
        type: double # [cpp]
        description: "Minimum time step to be used during the integration."

      - name: maximum_step_size # [py]
        type: float # [py]
      - name: maximumStepSize # [cpp]
        type: double # [cpp]
        description: "Maximum time step to be used during the integration."

      - name: relative_error_tolerance # [py]
        type: numpy.ndarray[numpy.float64[m, n]] # [py]
      - name: relativeErrorTolerance # [cpp]
        type: Eigen::Matrix # [cpp]
        description: "Relative vector tolerance to adjust the time step."

      - name: absolute_error_tolerance # [py]
        type: numpy.ndarray[numpy.float64[m, n]] # [py]
      - name: absoluteErrorTolerance # [cpp]
        type: Eigen::Matrix # [cpp]
        description: "Absolute vector tolerance to adjust the time step."

      - name: assess_termination_on_minor_steps # [py]
        type: bool, default=false # [py]
      - name: assessTerminationOnMinorSteps # [cpp]
        type: bool, default=false # [cpp]
        description: |
          Whether the propagation termination conditions should be evaluated during the intermediate sub-steps of the
          integrator (true) or only at the end of each integration step (false).

      - name: safety_factor # [py]
        type: float, default=0.8 # [py]
      - name: safetyFactorForNextStepSize # [cpp]
        type: double, default=0.8 # [cpp]
        description: "Safety factor used in the step size control."

      - name: maximum_factor_increase # [py]
        type: float, default=4.0 # [py]
      - name: maximumFactorIncreaseForNextStepSize # [cpp]
        type: double, default=4.0 # [cpp]
        description: |
          Maximum increase between consecutive time steps, expressed as the factor between new and old step size.

      - name: minimum_factor_increase # [py]
        type: float, default=0.1 # [py]
      - name: minimumFactorDecreaseForNextStepSize # [cpp]
        type: double, default=0.1 # [cpp]
        description: |
          Minimum increase between consecutive time steps, expressed as the factor between new and old step size.

      - name: throw_exception_if_minimum_step_exceeded # [py]
        type: bool, default=true # [py]
        description: |
          If set to false, the variable step integrator will use the minimum step size specified when the algorithm
          computes the optimum one to be lower, instead of throwing an exception.

    returns:
        type: RungeKuttaVariableStepSettingsScalarTolerances # [py]
        description: RungeKuttaVariableStepSettingsScalarTolerances object. # [py]
        type: RungeKuttaVariableStepSettingsScalarTolerances # [cpp]
        description: RungeKuttaVariableStepSettingsScalarTolerances object. # [cpp]


#######################################################################

  # Runge Kutta variable step size with vector tolerances
  - name: runge_kutta_variable_step_size_vector_tolerances # [py]
  - name: rungeKuttaVariableStepSettingsVectorTolerances # [cpp]
    short_summary: "Creates the settings for the Runge-Kutta variable step size integrator with vector tolerances."
    extended_summary: |
      NOTE: THIS FUNCTION IS DEPRECATED, IT IS RECOMMENDED TO USE THE NEW :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.runge_kutta_variable_step` INTERFACE INSTEAD
      
      Factory function to create settings for the Runge-Kutta variable step size integrator with vector tolerances.
      For this integrator, the step size is varied based on the tolerances and safety factor provided.
      The tolerance is composed of an absolute and a relative part.
      Different coefficient sets (Butcher's tableau) can be used (see the `CoefficientSets` enum).

    parameters:
      - name: initial_time_step # [py]
        type: float # [py]
      - name: initialTimeStep # [cpp]
        type: double # [cpp]
        description: "Initial time step to be used."

      - name: coefficient_set # [py]
        type: CoefficientSets # [py]
      - name: coefficientSet # [cpp]
        type: CoefficientSets # [cpp]
        description: "Coefficient set (Butcher's tableau) to be used in the integration."

      - name: minimum_step_size # [py]
        type: float # [py]
      - name: minimumStepSize # [cpp]
        type: double # [cpp]
        description: "Minimum time step to be used during the integration."

      - name: maximum_step_size # [py]
        type: float # [py]
      - name: maximumStepSize # [cpp]
        type: double # [cpp]
        description: "Maximum time step to be used during the integration."

      - name: relative_error_tolerance # [py]
        type: numpy.ndarray[numpy.float64[m, n]] # [py]
      - name: relativeErrorTolerance # [cpp]
        type: Eigen::Matrix # [cpp]
        description: "Relative vector tolerance to adjust the time step."

      - name: absolute_error_tolerance # [py]
        type: numpy.ndarray[numpy.float64[m, n]] # [py]
      - name: absoluteErrorTolerance # [cpp]
        type: Eigen::Matrix # [cpp]
        description: "Absolute vector tolerance to adjust the time step."

      - name: assess_termination_on_minor_steps # [py]
        type: bool, default=false # [py]
      - name: assessTerminationOnMinorSteps # [cpp]
        type: bool, default=false # [cpp]
        description: |
          Whether the propagation termination conditions should be evaluated during the intermediate sub-steps of the
          integrator (true) or only at the end of each integration step (false).

      - name: safety_factor # [py]
        type: float, default=0.8 # [py]
      - name: safetyFactorForNextStepSize # [cpp]
        type: double, default=0.8 # [cpp]
        description: "Safety factor used in the step size control."

      - name: maximum_factor_increase # [py]
        type: float, default=4.0 # [py]
      - name: maximumFactorIncreaseForNextStepSize # [cpp]
        type: double, default=4.0 # [cpp]
        description: |
          Maximum increase between consecutive time steps, expressed as the factor between new and old step size.

      - name: minimum_factor_increase # [py]
        type: float, default=0.1 # [py]
      - name: minimumFactorDecreaseForNextStepSize # [cpp]
        type: double, default=0.1 # [cpp]
        description: |
          Minimum increase between consecutive time steps, expressed as the factor between new and old step size.

      - name: throw_exception_if_minimum_step_exceeded # [py]
        type: bool, default=true # [py]
        description: |
          If set to false, the variable step integrator will use the minimum step size specified when the algorithm
          computes the optimum one to be lower, instead of throwing an exception.

    returns:
        type: RungeKuttaVariableStepSizeSettingsVectorTolerances # [py]
        description: RungeKuttaVariableStepSizeSettingsVectorTolerances object. # [py]
        type: RungeKuttaVariableStepSizeSettingsVectorTolerances # [cpp]
        description: RungeKuttaVariableStepSizeSettingsVectorTolerances object. # [cpp]

#######################################################################

  # Bulirsch-Stoer integrator
  - name: bulirschStoerIntegratorSettings # [cpp]
  - name: bulirsch_stoer # [py]
    short_summary: "Creates the settings for the Bulirsch-Stoer integrator."
    extended_summary: |
    
      NOTE: THIS FUNCTION IS DEPRECATED, IT IS RECOMMENDED TO USE THE NEW :func:`~tudatpy.numerical_simulation.propagation_setup.integrator.bulirsch_stoer_variable_step` INTERFACE INSTEAD
      
      Factory function to create settings for the Bulirsch-Stoer integrator.
      For this integrator, the step size is varied based on the tolerances and safety factor provided.
      The tolerance is composed of an absolute and a relative part.
      Different extrapolation sequences can be used (see the `ExtrapolationMethodStepSequences` enum).

    parameters:
      - name: initialTimeStep # [cpp]
        type: double # [cpp]
      - name: initial_time_step # [py]
        type: float # [py]
        description: Initial time step to be used.

      - name: extrapolationSequence # [cpp]
        type: ExtrapolationMethodStepSequences # [cpp]
      - name: extrapolation_sequence # [py]
        type: ExtrapolationMethodStepSequences # [py]
        description: Extrapolation sequence to be used in the integration.

      - name: maximumNumberOfSteps # [cpp]
        type: int # [cpp]
      - name: maximum_number_of_steps # [py]
        type: int # [py]
        description: Number of entries in the sequence (e.g., number of integrations used for a single extrapolation).

      - name: minimumStepSize # [cpp]
        type: double # [cpp]
      - name: minimum_step_size # [py]
        type: float # [py]
        description: Minimum time step to be used during the integration.

      - name: maximumStepSize # [cpp]
        type: double # [cpp]
      - name: maximum_step_size # [py]
        type: float # [py]
        description: Maximum time step to be used during the integration.

      - name: relativeErrorTolerance # [cpp]
        type: double, default=1.0E-12 # [cpp]
      - name: relative_error_tolerance # [py]
        type: float, default=1.0E-12 # [py]
        description: Relative tolerance to adjust the time step.

      - name: absoluteErrorTolerance # [cpp]
        type: double, default=1.0E-12 # [cpp]
      - name: absolute_error_tolerance # [py]
        type: float, default=1.0E-12 # [py]
        description: Relative tolerance to adjust the time step.

      - name: assessTerminationOnMinorSteps # [cpp]
        type: bool, default=false # [cpp]
      - name: assess_termination_on_minor_steps # [py]
        type: bool, default=false # [py]
        description: Whether the propagation termination conditions should be evaluated during the intermediate sub-steps of the integrator (true) or only at the end of each integration step (false).

      - name: safetyFactorForNextStepSize # [cpp]
        type: double, default=0.7 # [cpp]
      - name: safety_factor # [py]
        type: float, default=0.7 # [py]
        description: Safety factor used in the step size control.

      - name: maximumFactorIncreaseForNextStepSize # [cpp]
        type: double, default=10.0 # [cpp]
      - name: maximum_factor_increase # [py]
        type: float, default=10.0 # [py]
        description: Maximum increase between consecutive time steps, expressed as the factor between new and old step size.

      - name: minimumFactorDecreaseForNextStepSize # [cpp]
        type: double, default=0.1 # [cpp]
      - name: minimum_factor_increase # [py]
        type: float, default=0.1 # [py]
        description: Minimum increase between consecutive time steps, expressed as the factor between new and old step size.

    returns:
        type: BulirschStoerIntegratorSettings
        description: BulirschStoerIntegratorSettings object.


