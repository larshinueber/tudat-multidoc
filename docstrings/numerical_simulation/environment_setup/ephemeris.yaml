#########################################################################
#    ███    ███  ██████  ██████  ██    ██ ██      ███████
#    ████  ████ ██    ██ ██   ██ ██    ██ ██      ██
#    ██ ████ ██ ██    ██ ██   ██ ██    ██ ██      █████
#    ██  ██  ██ ██    ██ ██   ██ ██    ██ ██      ██
#    ██      ██  ██████  ██████   ██████  ███████ ███████
#########################################################################
#  Ephemeris Setup ( approximatePlanetPositionsBase.h, createEphemeris.h )


extended_summary: |
  This module contains a set of factory functions for setting up the
  ephemeris models of celestial bodies in an environment. Below a short
  overview of aspects of some of the ephemeris models in order to aid in
  properly selecting an choosing a model.

  **Spice-based models** For many typical applications, natural body ephemerides 
  will be calculated from `Spice kernels <https://docs.tudat.space/en/latest/_src_user_guide/state_propagation/environment_setup/default_env_models.html#spice-in-tudat>`_. 
  In some cases, a user may find that the default Spice kernels are insufficient 
  for their purposes, due to one of two reasons:

  * The body for which the state is required *is* in the ephemeris Spice kernel, but the time at which the state is needed lies outside of the bounds for which the Spice kernel has data
  * The body for which the state is required *is not* in the ephemeris Spice kernel

  In both cases, a user should load additional Spice kernels. This can be done using the :func:`~tudatpy.interface.spice.load_kernel`. Spice kernels for many bodies may be found in a number of places.
  The 'goto' place for Spice kernels for ephemerides is the NAIF website (developers of Spice), which you can find
  `here <https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/>`_.

  **Use of scaled models** For a sensitivity analysis (among others) it may be useful to modify the ephemeris of a body, for instance
  to emulate the influence of a 1 km offset in the state provided by the nominal ephemeris. Unlike most other environment models,
  this cannot be achieved (at least not for most types of ephemerides) by modifying a single defining parameter of the model.
  Instead, we provide the functions
  :func:`~tudatpy.numerical_simulation.environment_setup.ephemeris.scaled_by_vector` and
  :func:`~tudatpy.numerical_simulation.environment_setup.ephemeris.scaled_by_vector_function`,
  which take nominal ephemeris settings, and add a user-defined variation (constant or time-varying; absolute or relative) to the
  inertial Cartesian state elements produced by the ephemeris.

  **Using the ephemeris outside the propagation** In various cases, the ephemeris object is useful to use independently of the propagation. Details can be found in the API entry for :class:`~tudatpy.numerical_simulation.environment.Ephemeris`, but we provide a short example here as well.

  .. code-block:: python

    bodies = .... // Create system of bodies
    earth_ephemeris = bodies.get('Earth').ephemeris
    earth_state_at_epoch = earth_ephemeris.cartesian_state( epoch )

  where the ``epoch`` input is (as always in Tudat) the time in seconds since J2000. The ``earth_state_at_epoch`` is always in a frame with inertial orientation. The specific orientation and origin can be access from the :attr:`~tudatpy.numerical_simulation.environment.Ephemeris.frame_orientation` and :attr:`~tudatpy.numerical_simulation.environment.Ephemeris.frame_origin` attributes.

#########################################################################
#  ███████ ███   ██ ██    ██ ███    ███  ██████
#  ██      ████  ██ ██    ██ ████  ████ █
#  █████   ██ ██ ██ ██    ██ ██ ████ ██  █████
#  ██      ██  ████ ██    ██ ██  ██  ██       █
#  ███████ ██    ██  ██████  ██      ██ ██████
#########################################################################

  # no enums


#########################################################################
#   ██████ ██          ██      ██████  ██████ ███████  ██████
#  ██      ██         ████    █       █       ██      █
#  ██      ██        ██  ██    █████   █████  █████    █████
#  ██      ██       ████████        █       █ ██            █
#   ██████ ███████ ██      ██ ██████  ██████  ███████ ██████
#########################################################################

classes:
  # base class:
  #######################################################################

  - name: EphemerisSettings
    short_summary: "Base class for providing settings for ephemeris model."
    extended_summary: |
      Functional (base) class for settings of ephemeris models that require no information in addition to their type (and frame origin and orientation).
      Ephemeris model classes requiring additional information must be created using an object derived from this class.

    properties: # [py]
      - name: ephemeris_type # [py]
        type: EphemerisType # [py]
        description: Type of ephemeris that is to be created. # [py]
        readonly: True # [py]

      - name: frame_origin # [py]
        type: str # [py]
        description: Origin of frame in which ephemeris data is to be defined. # [py]

      - name: frame_orientation # [py]
        type: str # [py]
        description: Orientation of frame in which ephemeris data is to be defined. # [py]

      - name: make_multi_arc_ephemeris # [py]
        type: bool # [py]
        description: Boolean denoting whether the ephemeris that is to be created is a multi-arc ephemeris. # [py]


    methods:
      - name: ctor # [cpp]
        #      - name: __init__ # [py]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for ephemerides should be instantiated through the factory functions of a derived class." # [cpp]

      - name: getEphemerisType # [cpp]
        short_summary: "Retrieve ephemeris type." # [cpp]
        extended_summary: "Function to retrieve the type of ephemeris that is to be created through the settings object." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: EphemerisType # [cpp]
            description: Type of ephemeris that is to be created. # [cpp]

      - name: getFrameOrigin # [cpp]
        short_summary: "Retrieve frame origin." # [cpp]
        extended_summary: "Function to retrieve the frame origin of the ephemeris that is to be created through the settings object." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: std::string # [cpp]
            description: Ephemeris frame origin. # [cpp]

      - name: getFrameOrientation # [cpp]
        short_summary: "Retrieve frame orientation." # [cpp]
        extended_summary: "Function to retrieve the frame orientation of the ephemeris that is to be created through the settings object." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: std::string # [cpp]
            description: Ephemeris frame orientation. # [cpp]

      - name: getMultiArcEphemeris # [cpp]
        short_summary: "Check whether the ephemeris that is to be created is a multi-arc ephemeris." # [cpp]
        extended_summary: "Function to retrieve boolean denoting whether the ephemeris that is to be created is a multi-arc ephemeris." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: std::string # [cpp]
            description: Boolean denoting whether the ephemeris that is to be created is a multi-arc ephemeris. # [cpp]

      - name: resetFrameOrigin # [cpp]
        short_summary: "Reset frame origin." # [cpp]
        extended_summary: "Function to reset the frame origin of the ephemeris that is to be created through the settings object." # [cpp]
        parameters: # [cpp]
          - name: frameOrigin # [cpp]
            type: std::string # [cpp]
            description: Ephemeris frame origin. # [cpp]

      - name: resetFrameOrientation # [cpp]
        short_summary: "Reset frame orientation." # [cpp]
        extended_summary: "Function to reset the frame orientation of the ephemeris that is to be created through the settings object." # [cpp]
        parameters: # [cpp]
          - name: frameOrientation # [cpp]
            type: std::string # [cpp]
            description: Ephemeris frame orientation. # [cpp]

      - name: resetMakeMultiArcEphemeris # [cpp]
        short_summary: "Set whether the ephemeris that is to be created is a multi-arc ephemeris." # [cpp]
        extended_summary: "Function to reset boolean denoting whether the ephemeris that is to be created is a multi-arc ephemeris." # [cpp]
        parameters: # [cpp]
          - name: makeMultiArcEphemeris # [cpp]
            type: std::string # [cpp]
            description: Boolean denoting whether the ephemeris that is to be created is a multi-arc ephemeris. # [cpp]


  # derived classes:
  #######################################################################

  - name: ScaledEphemerisSettings
    short_summary: "Class for defining settings from scaling existing ephemeris settings."
    extended_summary: "`EphemerisSettings` derived class for a new ephemeris created from scaling an existing ephemeris settings object. It allows the user to apply a scaling factor to the resulting Cartesian states (for instance for an uncertainty analysis)."

    # class is not exposed as class in tudatpy
    # attributes:

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of the `ScaledEphemerisSettings` class should be created through the scaledEphemerisSettings` factory function." # [cpp]
      #      - name: __init__ # [py]
      #        short_summary: "Constructor."
      #        extended_summary: "Instances of the `ScaledEphemerisSettings` class should be created through the `scaled` factory function." # [py]

      - name: getBaseSettings # [cpp]
        short_summary: "Retrieve base settings of (un)scaled ephemeris." # [cpp]
        extended_summary: "Function to retrieve the base settings (frame origin and orientation) of (un)scaled ephemeris." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: std::shared_ptr< EphemerisSettings > # [cpp]
            description: Base settings (frame origin and orientation) of (un)scaled ephemeris. # [cpp]

      - name: getScaling # [cpp]
        short_summary: "Retrieve scaling factor(s)." # [cpp]
        extended_summary: | # [cpp]
          Function to retrieve the scaling factor(s). Can be constant factor for all elements of Cartesian state, constant factor for each Cartesian state or even custom time-dependent function for scaling factors for each Cartesian state. # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: double, Eigen::Vector6d, std::function< Eigen::Vector6d( const double ) > # [cpp]
            description: Scaling factor(s) for ephemeris scaling. # [cpp]

      - name: getIsScalingAbsolute # [cpp]
        short_summary: "Check whether ephemeris scaling is absolute." # [cpp]
        extended_summary: | # [cpp]
          Function to retrieve the boolean indicating whether ephemeris scaling is absolute. When set to true (default false), the scaling factors will be interpreted as values and added to the state. # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: bool # [cpp]
            description: Boolean indicating whether ephemeris scaling is absolute. # [cpp]

  #######################################################################

  - name: DirectSpiceEphemerisSettings
    short_summary: "Class for defining settings of an ephemeris linked directly to Spice."
    extended_summary: "`EphemerisSettings` derived class for ephemeris which are directly linked to Spice."

    properties: # [py]
      - name: correct_for_stellar_aberration # [py]
        type: bool # [py]
        description: Boolean defining whether to correct for stellar aberrations in retrieved values (of observed state). # [py]
        readonly: True # [py]

      - name: correct_for_light_time_aberration # [py]
        type: bool # [py]
        description: Boolean defining whether to correct for light time in retrieved values (of observed state). # [py]
        readonly: True # [py]

      - name: converge_light_time_aberration # [py]
        type: bool # [py]
        description: Boolean defining whether to use single iteration or max. 3 iterations for calculating light time correction. # [py]
        readonly: True # [py]

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of the `DirectSpiceEphemerisSettings` class should be created through the `directSpiceEphemerisSettings` factory function." # [cpp]
      #      - name: __init__ # [py]
      #        short_summary: "Constructor." # [py]
      #        extended_summary: "Instances of the `DirectSpiceEphemerisSettings` class should be created through the `direct_spice` factory function." # [py]

      - name: getCorrectForStellarAberration # [cpp]
        short_summary: "Check whether to correct for stellar aberration." # [cpp]
        extended_summary: | # [cpp]
          Function to retrieve the boolean which indicates whether to correct for stellar aberration in retrieved values (of observed state). # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: bool # [cpp]
            description: Boolean defining whether to correct for stellar aberrations in retrieved values (of observed state). # [cpp]

      - name: getCorrectForLightTimeAberration # [cpp]
        short_summary: "Check whether to correct for light time aberration." # [cpp]
        extended_summary: | # [cpp]
          Function to retrieve the boolean which indicates whether to correct for light time aberration in retrieved values (of observed state). # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: bool # [cpp]
            description: Boolean defining whether to correct for light time aberrations in retrieved values (of observed state). # [cpp]

      - name: getConvergeLightTimeAberration # [cpp]
        short_summary: "Check whether to use iterative solution for light time." # [cpp]
        extended_summary: | # [cpp]
          Function to retrieve the boolean which indicates whether to use single iteration or max. 3 iterations for calculating light time. # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: bool # [cpp]
            description: Boolean defining whether to use single iteration or max. 3 iterations for calculating light time. # [cpp]

  #######################################################################

  - name: InterpolatedSpiceEphemerisSettings
    short_summary: "Class for defining settings of an ephemeris interpolated from Spice data."
    extended_summary: "`DirectSpiceEphemerisSettings` derived class for setting ephemerides to be created from interpolated Spice ephemeris data."

    properties: # [py]
      - name: initial_time # [py]
        type: float # [py]
        description: "Initial time from which interpolated data from Spice should be created." # [py]
        readonly: True # [py]

      - name: final_time # [py]
        type: float # [py]
        description: "Final time from which interpolated data from Spice should be created." # [py]
        readonly: True # [py]

      - name: time_step # [py]
        type: float # [py]
        description: "Time step setting to be used for the state interpolation." # [py]
        readonly: True # [py]


    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of the `InterpolatedSpiceEphemerisSettings` class should be created through the `interpolatedSpiceEphemerisSettings` factory function." # [cpp]
      #      - name: __init__ # [py]
      #        short_summary: "Constructor." # [py]
      #        extended_summary: "Instances of the `InterpolatedSpiceEphemerisSettings` class should be created through the `interpolated_spice` factory function." # [py]

      - name: getInitialTime # [cpp]
        short_summary: "Retrieve initial time of interpolation." # [cpp]
        extended_summary: "Function to retrieve initial time from which interpolated data from Spice should be created." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: double # [cpp]
            description: "Initial time from which interpolated data from Spice should be created." # [cpp]

      - name: getFinalTime # [cpp]
        short_summary: "Retrieve final time of interpolation." # [cpp]
        extended_summary: "Function to retrieve final time from which interpolated data from Spice should be created." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: double # [cpp]
            description: "Final time from which interpolated data from Spice should be created." # [cpp]

      - name: getTimeStep # [cpp]
        short_summary: "Retrieve time step used for interpolation." # [cpp]
        extended_summary: "Function to retrieve time step setting to be used for the state interpolation." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: double # [cpp]
            description: "Time step setting to be used for the state interpolation." # [cpp]

  #######################################################################

  - name: ApproximateJplEphemerisSettings
    short_summary: "Class for creating settings of approximate ephemeris for major planets."
    extended_summary: "`EphemerisSettings` derived class for approximate ephemeris for major planets as implemented in ApproximateJplEphemerisSettings class and derived class (described in `this document <https://ssd.jpl.nasa.gov/planets/approx_pos.html>`_)."

  #######################################################################

  - name: ConstantEphemerisSettings
    short_summary: "Class for defining settings of constant ephemerides."
    extended_summary: "`EphemerisSettings` derived class for ephemerides producing a constant (time-independent) state."

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of the `ConstantEphemerisSettings` class should be created through the `constantEphemerisSettings` factory function." # [cpp]
      #      - name: __init__ # [py]
      #        short_summary: "Constructor." # [py]
      #        extended_summary: "Instances of the `ConstantEphemerisSettings` class should be created through the `constant` factory function." # [py]


      - name: getConstantState # [cpp]
        short_summary: "Retrieve the constant state." # [cpp]
        extended_summary: "Function to retrieve the constant (time-independent) state that defines the ephemeris to be created." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: Eigen::Vector6d # [cpp]
            description: "Constant (time-independent) state that defines the ephemeris to be created." # [cpp]

  #######################################################################

  - name: CustomEphemerisSettings
    short_summary: "Class for defining settings of a custom ephemeris."
    extended_summary: "`EphemerisSettings` derived class for ephemerides producing a custom state (e.g. arbitrary state as a function of time)."

    properties: # [py]
      - name: custom_state_function # [py]
        type: Callable[[float], numpy.ndarray[numpy.float64[6, 1]]] # py
        description: "Function returning the state as a function of time." # [py]
        readonly: True # [py]

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of the `CustomEphemerisSettings` class should be created through the `customEphemerisSettings` factory function." # [cpp]
      #      - name: __init__ # [py]
      #        short_summary: "Constructor." # [py]
      #        extended_summary: "Instances of the `CustomEphemerisSettings` class should be created through the `custom` factory function." # [py]


      - name: getCustomStateFunction # [cpp]
        short_summary: "Retrieve the function returning the state as a function of time." # [cpp]
        extended_summary: "Function to retrieve the function returning the state as a function of time." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: std::function< Eigen::Vector6d > # [cpp]
            description: "Function returning the state as a function of time." # [cpp]

  #######################################################################

  - name: KeplerEphemerisSettings # [cpp]
    short_summary: "Class for defining settings of an ideal Kepler orbit ephemeris." # [cpp]
    extended_summary: "`EphemerisSettings` derived class for ephemerides which represent an ideal Kepler orbit."

    properties: # [py]
      - name: initial_state_in_keplerian_elements # [py]
        type: numpy.ndarray[numpy.float64[6, 1]] # [py]
        description: "Kepler elements at time epochOfInitialState." # [py]
        readonly: True # [py]
      - name: epoch_of_initial_state # [py]
        type: float # [py]
        description: "Time at which initialStateInKeplerianElements represents the Keplerian state." # [py]
        readonly: True # [py]
      - name: central_body_gravitational_parameter # [py]
        type: float # [py]
        description: "Gravitational parameter of the central body that is used in the computations." # [py]
        readonly: True # [py]
      - name: root_finder_absolute_tolerance # [py]
        type: float # [py]
        description: |
          Convergence tolerance on iterative conversion from mean to eccentric anomaly;
          applies every time a cartesian state is requested from the kepler ephemeris, such as during propagation.
        readonly: True # [py]
      - name: root_finder_maximum_number_of_iterations # [py]
        type: float # [py]
        description: |
          Maximum iteration on iterative conversion from mean to eccentric anomaly;
          applies every time a cartesian state is requested from the kepler ephemeris, such as during propagation.
        readonly: True # [py]

    methods:

      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of the `KeplerEphemerisSettings` class should be created through the `keplerEphemerisSettings` or `keplerEphemerisFromSpiceSettings` factory function." # [cpp]
      #      - name: __init__ # [py]
      #        short_summary: "Constructor." # [py]
      #        extended_summary: "Instances of the `KeplerEphemerisSettings` class should be created through the `keplerian` or `keplerian_from_spice` factory function." # [py]


      - name: getInitialStateInKeplerianElements # [cpp]
        short_summary: "Retrieve the kepler elements at time epochOfInitialState." # [cpp]
        extended_summary: "Function to retrieve the kepler elements at time epochOfInitialState." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: Eigen::Vector6d # [cpp]
            description: "Kepler elements at time epochOfInitialState." # [cpp]

      - name: getEpochOfInitialState # [cpp]
        short_summary: "Retrieve the initial epoch of propagation." # [cpp]
        extended_summary: "Function to retrieve the initial epoch from which propagation of Kepler orbit is performed." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: double # [cpp]
            description: "Time at which initialStateInKeplerianElements represents the Keplerian state." # [cpp]

      - name: getCentralBodyGravitationalParameter # [cpp]
        short_summary: "Retrieve the gravitational parameter of central body." # [cpp]
        extended_summary: "Function to retrieve the gravitational parameter of central body about which the Kepler orbit is defined." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: double # [cpp]
            description: "Gravitational parameter of the central body that is used in the computations." # [cpp]

      - name: getRootFinderAbsoluteTolerance # [cpp]
        short_summary: "Retrieve convergence tolerance for anomaly conversion." # [cpp]
        extended_summary: "Function to retrieve the convergence tolerance for root finder used to convert mean to eccentric anomaly." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: double # [cpp]
            description: "Convergence tolerance for root finder used to convert mean to eccentric anomaly on each call to getCartesianState." # [cpp]

      - name: getRootFinderMaximumNumberOfIterations # [cpp]
        short_summary: "Retrieve the maximum number of iteration for anomaly conversion." # [cpp]
        extended_summary: "Function to retrieve the maximum number of iteration for root finder used to convert mean to eccentric anomaly." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: double # [cpp]
            description: "Maximum iteration for root finder used to convert mean to eccentric anomaly on each call to getCartesianState." # [cpp]

  #######################################################################

  - name: TabulatedEphemerisSettings
    short_summary: "Class for defining settings of ephemeris to be created from tabulated data."
    extended_summary: "`EphemerisSettings` derived class for ephemeris created from tabulated data. The provided data is interpolated into ephemerides."

    properties: # [py]
      - name: body_state_history # [py]
        type: Dict[[float], numpy.ndarray[numpy.float64[6, 1]]] # [py] (%! better here)
        description: Dictionary of the discrete state history data from which ephemeris is to be created. # [py]
        readonly: True # [py]
      - name: use_long_double_states # [py]
        type: bool # [py]
        description: Boolean defining whether increased numerical precision (long double type) is to be used when creating the ephemeris. # [py]
        readonly: True # [py]

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of the `TabulatedEphemerisSettings` class should be created through the `tabulatedEphemerisSettings` factory function." # [cpp]
      #      - name: __init__ # [py]
      #        short_summary: "Constructor."  # [py]
      #        extended_summary: "Instances of the `TabulatedEphemerisSettings` class should be created through the `tabulated` factory function." # [py]

      - name: getBodyStateHistory # [cpp]
        short_summary: "Retrieve body state history." # [cpp]
        extensive_summary: "Function to retrieve data map defining discrete state history data from which ephemeris is to be created." # [cpp]
        parameters: # [cpp]
          - name: None # [cpp]
        returns: # [cpp]
            type: std::map< double, Eigen::Vector6d > # [cpp]
            description: Data map defining discrete data from which an ephemeris is to be created. # [cpp]

      - name: setUseLongDoubleStates # [cpp]
        short_summary: "Set whether increased numerical precision is used." # [cpp]
        extended_summary: "Function to set boolean indicating whether increased numerical precision (long double type) is to be used when creating the ephemeris." # [cpp]
        parameters: # [cpp]
          - name: useLongDoubleStates # [cpp]
            type: bool # [cpp]
            description: Boolean indicating whether increased numerical precision (long double type) is to be used when creating the ephemeris. # [cpp]



##############################################################################
#  ███████ ██    ██ ███    ██  ██████ ████████ ██  ██████  ███    ██  ██████
#  ██      ██    ██ ████   ██ ██         ██    ██ ██    ██ ████   ██ █
#  █████   ██    ██ ██ ██  ██ ██         ██    ██ ██    ██ ██ ██  ██  █████
#  ██      ██    ██ ██  ██ ██ ██         ██    ██ ██    ██ ██  ██ ██       █
#  ██       ██████  ██   ████  ██████    ██    ██  ██████  ██   ████ ██████
##############################################################################

functions:
  # factory functions:
  #######################################################################

  - name: directSpiceEphemerisSettings # [cpp]
    short_summary: "Factory function for creating ephemeris model settings entirely from Spice." # [cpp]
    extended_summary: | # [cpp]
      Factory function for settings object, defining ephemeris model directly and entirely from Spice. # [cpp]
      Requires an appropriate Spice kernel to be loaded. # [cpp]
      This function creates an instance of an EphemerisSettings` derived `DirectSpiceEphemerisSettings` class. # [cpp]

    parameters: # [cpp]

      - name: frameOrigin # [cpp]
        type: std::string, default="SSB" # [cpp]
        description: "Origin of frame in which ephemeris data is defined." # [cpp]

      - name: frameOrientation # [cpp]
        type: std::string, default="ECLIPJ2000" # [cpp]
        description: "Orientation of frame in which ephemeris data is defined." # [cpp]

      - name: correctForStellarAberration # [cpp]
        type: bool, default=false # [cpp]
        description: "Boolean whether to correct for stellar aberrations in retrieved values (of observed state)." # [cpp]

      - name: correctForLightTimeAberration # [cpp]
        type: bool, default=false # [cpp]
        description: "Boolean whether to correct for light time in retrieved values (of observed state)." # [cpp]

      - name: convergeLightTimeAberration # [cpp]
        type: bool, default=false # [cpp]
        description: "Boolean whether to use single iteration or max. 3 iterations for calculating light time." # [cpp]

    returns: # [cpp]
        type: DirectSpiceEphemerisSettings # [cpp]
        description: Instance of DirectSpiceEphemerisSettings class # [cpp]

  #######################################################################

  - name: direct_spice # [py]
  - name: directSpiceEphemerisSettings # [cpp] # overload 1
    short_summary: "Factory function for creating ephemeris model settings entirely from Spice."
    extended_summary: |
      Factory function for settings object, defining ephemeris model directly and entirely from Spice.
      Requires an appropriate Spice kernel to be loaded.

    parameters:
      - name: frame_origin # [py]
        type: str, default="SSB" # [py]
      - name: frameOrigin # [cpp]
        type: std::string, default="SSB" # [cpp]
        description: "Origin of frame in which ephemeris data is defined."

      - name: frame_orientation # [py]
        type: str, default="ECLIPJ2000" # [py]
      - name: frameOrientation # [cpp]
        type: std::string, default="ECLIPJ2000" # [cpp]
        description: "Orientation of frame in which ephemeris data is defined."

      - name: body_name_to_use # [py]
        type: str, default = "" # [py]
      - name: bodyNameOverride # [cpp]
        type: std::string, default = "" # [cpp]
        description: "Body from which Spice ephemeris is to be created."

    returns:
        type: DirectSpiceEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.DirectSpiceEphemerisSettings` class


    examples: |
      In this example, we create barycentric (origin: SSB) :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` with axes along J2000, using data directly from spice:

      .. code-block:: python # [py]
         # [py]
         frame_origin = "SSB" # [py]
         frame_orientation = "J2000" # [py]
         body_settings.get( "Jupiter" ).ephemeris_settings = environment_setup.ephemeris.direct_spice( # [py]
         	frame_origin, frame_orientation) # [py]

      .. code-block:: cpp # [cpp]
         # [cpp]
         std::string frameOrigin = "SSB"; # [cpp]
         std::string frameOrientation = "J2000"; # [cpp]
         // create ephemeris settings and add to body settings of body "Jupiter" # [cpp]
         bodySettings[ "Jupiter" ]->ephemerisSettings = std::make_shared< DirectSpiceEphemerisSettings >( frameOrigin, frameOrientation ); # [cpp]

      Alternatively, we can assign the DirectSpiceEphemerisSettings of Jupiter (or any other body for which a direct Spice ephemeris is available) to any custom body:

      .. code-block:: python # [py]
         # [py]
         frame_origin = "SSB" # [py]
         frame_orientation = "J2000" # [py]
         body_name_to_use =  "Jupiter" # [py]
         # create ephemeris settings from "Jupiter" spice data and add to body settings of body "CustomBody" # [py]
         body_settings.get( "CustomBody" ).ephemeris_settings = environment_setup.ephemeris.direct_spice( # [py]
         	frame_origin, frame_orientation, body_name_to_use ) # [py]

      .. code-block:: cpp # [cpp]
         # [cpp]
         std::string frameOrigin = "SSB"; # [cpp]
         std::string frameOrientation = "J2000"; # [cpp]
         std::string bodyNameToUse = "Jupiter"; # [cpp]
         // create ephemeris settings from "Jupiter" spice data and add to body settings of body "CustomBody" # [cpp]
         bodySettings[ "CustomBody" ]->ephemerisSettings = std::make_shared< DirectSpiceEphemerisSettings >( frameOrigin, frameOrientation, bodyNameToUse); # [cpp]

  #######################################################################

  - name: interpolated_spice # [py]
  - name: interpolatedSpiceEphemerisSettings # [cpp]
    short_summary: "Factory function for creating ephemeris model settings using interpolated Spice data."
    extended_summary: |
      Factory function for settings object defining an ephemeris model from interpolated Spice data.
      Using this option the state of the body is retrieved from Spice at regular intervals `before` the environment propagation (as opposed to during the propagation).
      These data are then used to create an interpolator, which is put into the environment, and called during the propagation.
      This option has the downside of being applicable only during a limited time interval and requiring the tabulated data to be stored in RAM,
      but may for `some special cases <https://docs.tudat.space/en/latest/_src_user_guide/state_propagation/environment_setup/default_env_models/default_bodies_limited_time_range.html>`_
      offer an advantage over a direct Spice ephemeris (:func:`~tudatpy.numerical_simulation.environment_setup.ephemeris.direct_spice`).

    parameters:

      - name: initial_time # [py]
        type: float # [py]
      - name: initialTime # [cpp]
        type: double # [cpp]
        description: "Initial time from which interpolated data from Spice should be created."

      - name: final_time # [py]
        type: float # [py]
      - name: finalTime # [cpp]
        type: double # [cpp]
        description: "Final time from which interpolated data from Spice should be created."

      - name: time_step # [py]
        type: float # [py]
      - name: timeStep # [cpp]
        type: double # [cpp]
        description: "Time step with which interpolated data from Spice should be created."

      - name: frame_origin # [py]
        type: str, default="SSB" # [py]
      - name: frameOrigin # [cpp]
        type: std::string, default="SSB" # [cpp]
        description: "Origin of frame in which ephemeris data is defined."

      - name: frame_orientation # [py]
        type: str, default="ECLIPJ2000" # [py]
      - name: frameOrientation # [cpp]
        type: std::string, default="ECLIPJ2000" # [cpp]
        description: "Orientation of frame in which ephemeris data is defined."

      - name: interpolator_settings # [py]
        type: std::make_shared< interpolators::InterpolatorSettings >, default=std::make_shared<tudat::interpolators::LagrangeInterpolatorSettings>(6))
      - name: interpolatorSettings # [cpp]
        type: std::make_shared< interpolators::InterpolatorSettings >, default=std::make_shared< interpolators::LagrangeInterpolatorSettings >( 6 )
        description: "Settings to be used for the state interpolation."

      - name: body_name_to_use # [py]
        type: str, default = "" # [py]
      - name: bodyNameOverride # [cpp]
        type: std::string, default = "" # [cpp]
        description: "Body from which Spice ephemeris is to be created."

    returns:
        type: InterpolatedSpiceEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.DirectSpiceEphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.InterpolatedSpiceEphemerisSettings` class


    examples: |
      In this example, we define :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` for Jupiter by retrieving ephemeris data from Spice at 3600 s intervals between t=0 and t=1.0E8:

      .. code-block:: python # [py]
        # [py]
        # Define the interpolation settings
        initial_time = 0.0 # [py]
        final_time = 1.0E8 # [py]
        time_step = 3600.0 # [py]
        # Define the ephemeris frame
        frame_origin = "SSB" # [py]
        frame_orientation = "J2000" # [py]
        # create ephemeris settings and add to body settings of body "Jupiter"
        body_settings.get( "Jupiter" ).ephemeris_settings = environment_setup.ephemeris.interpolated_spice( # [py]
          initial_time, final_time, time_step, frame_origin, frame_orientation ) # [py]

      # cpp code snippet unavailable # [cpp]

      By default, a 6th order Lagrange interpolator is used (NOTE: the Lagrange interpolator is not reliable at the edges of the interpolation interval, as discussed here: :func:`~tudatpy.math.interpolators.lagrange_interpolation`).
      Settings for an alternative interpolator can be use by specifying the optional input argument.
      Additionally, as is the case for the :func:`~tudatpy.numerical_simulation.environment_setup.ephemeris.direct_spice` and :func:`~tudatpy.numerical_simulation.environment_setup.ephemeris.approximate_jpl_model` functions, an optional input argument ``body_name_to_use`` allows to use an ephemeris model from Spice for some body and assign it to a custom body.

  #######################################################################
  # (%!) confirm that the approximatePlanetPositionsSettings FF situation is documented correctly
  - name: approximatePlanetPositionsSettings # [cpp] # (%! naming is misleading - Position vs Positions)
    short_summary: "Factory function for creating approximate ephemeris model settings for major planets." # [cpp]
    extended_summary: "Factory function for settings object, defining approximate ephemeris model for major planets. In this highly simplified ephemeris model, Keplerian elements of the major solar system bodies are modelled as linear functions of time and several sinusoidal variations (described in `this document <https://ssd.jpl.nasa.gov/planets/approx_pos.html>`_). Three-dimensional and circular-coplanar approximation may be used. This function creates an instance of an `EphemerisSettings` derived `ApproximatePlanetPositionsSettings` class." # [cpp]

    parameters: # [cpp]
      - name: bodyIdentifier # [cpp]
        type: ephemerides::ApproximatePlanetPositionsBase::BodiesWithEphemerisData # [cpp]
        description: "Identifier for the body that the ephemeris is to be created for." # [cpp]

      #- name: use_circular_coplanar_approximation # [py]
      #  type: bool, default=false # [py]
      #- name: useCircularCoplanarApproximation # [cpp]
      #  type: bool, default=false # [cpp]
      #  description: |
      #    Boolean defining whether a circular, coplanar orbit of the body is to be assumed, or whether a non-zero inclination and long-period changes in the orbit are to be included.

    returns: # [cpp]
        type: ApproximateJplEphemerisSettings # [cpp]
        description: Instance of ApproximateJplEphemerisSettings class # [cpp]

  #######################################################################

  - name: approximate_jpl_model # [py]
  - name: approximateJplEphemerisSettings # [cpp] # overload 1
    short_summary: "Factory function for creating approximate ephemeris model settings for major planets."
    extended_summary: |
      Factory function for settings object, defining approximate ephemeris model for major planets.
      In this highly simplified ephemeris model, Keplerian elements of the major solar system bodies are modelled as linear functions of time and several sinusoidal variations (described in `this document <https://ssd.jpl.nasa.gov/planets/approx_pos.html>`_).
      Note that this option is only available for solar system planets. For the case of the Earth the approximate ephemeris of the Earth-Moon barycenter is returned.

    parameters:
      - name: body_name # [py]
        type: str # [py]
      - name: bodyName # [cpp]
        type: std::string # [cpp]
        description: "String that is attempted to be matched to an identifier for the body that the ephemeris is to be created for."

    returns:
        type: ApproximateJplEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.ApproximateJplEphemerisSettings` class

    examples: |
      In this example, we create :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` for Jupiter using JPL's approximate planet position model:

      .. code-block:: python # [py]
         # [py]
         # create ephemeris settings and add to body settings of body "Jupiter" # [py]
         body_settings.get( "Jupiter" ).ephemeris_settings = environment_setup.ephemeris.approximate_jpl_model( "Jupiter" ) # [py]

      .. code-block:: cpp # [cpp]
         # [cpp]
         // create ephemeris settings and add to body settings of body "Jupiter" # [cpp]
         bodySettings[ "Jupiter" ]->ephemerisSettings = std::make_shared< ApproximatePlanetPositionSettings >(   # [cpp]
         							ephemerides::ApproximatePlanetPositionsBase::jupiter, false );                             # [cpp]

      Alternatively, we can assign the ApproximateJplEphemerisSettings of Jupiter (or any other body for which an approximate JPL ephemeris is available) to any custom body:

      .. code-block:: python # [py]
         # create ephemeris settings (normally used for Jupiter) and add to body settings of body "CustomBody" # [py]
         body_settings.get( "CustomBody" ).ephemeris_settings = environment_setup.ephemeris.approximate_jpl_model( "Jupiter" ) # [py]

      .. code-block:: cpp # [cpp]
         # [cpp]
         // create ephemeris settings and add to body settings of body "Jupiter" # [cpp]
         bodySettings[ "CustomBody" ]->ephemerisSettings = std::make_shared< ApproximatePlanetPositionSettings >(   # [cpp]
         							ephemerides::ApproximatePlanetPositionsBase::jupiter, false );   

  #######################################################################

  - name: constant # [py]
  - name: constantEphemerisSettings # [cpp]
    short_summary: "Factory function for creating constant ephemeris model settings."
    extended_summary: |
      Factory function for settings object, defining ephemeris model with a constant, time-independent state.

    parameters:
      - name: constant_state # [py]
        type: numpy.ndarray[numpy.float64[6, 1]] # [py]
      - name: constantState # [cpp]
        type: Eigen::Vector6d # [cpp]
        description: "Constant state that will be provided as output of the ephemeris at all times."

      - name: frame_origin # [py]
        type: str, default="SSB" # [py]
      - name: frameOrigin # [cpp]
        type: std::string, default="SSB" # [cpp]
        description: "Origin of frame in which ephemeris data is defined."

      - name: frame_orientation # [py]
        type: str, default="ECLIPJ2000" # [py]
      - name: frameOrientation # [cpp]
        type: std::string, default="ECLIPJ2000" # [cpp]
        description: "Orientation of frame in which ephemeris data is defined."

    returns:
        type: ConstantEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.ConstantEphemerisSettings` class


    examples: |
      In this example, we create :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` for a time-independent, constant state of Jupiter:

      .. code-block:: python # [py]
         # [py]
         # Define the constant cartesian state # [py]
         constant_cartesian_state = [100.0e9, 100.0e9, 100.0e9, 10.0e3, 10.0e3, 10.0e3] # [py]
         # Define the ephemeris frame # [py]
         frame_origin = "SSB" # [py]
         frame_orientation = "J2000" # [py]
         # Make the ephemeris settings # [py]
         body_settings.get( "Jupiter" ).ephemeris_settings = environment_setup.ephemeris.constant( # [py]
           constant_cartesian_state, # [py]
           frame_origin, frame_orientation) # [py]

      # cpp code snippet unavailable # [cpp]

  #######################################################################

  - name: custom_ephemeris # [py]
  - name: customEphemerisSettings # [cpp]
    short_summary: "Factory function for creating custom ephemeris model settings."
    extended_summary: |
      Factory function for settings object, defining ephemeris model with a custom state.
      This allows the user to provide a custom state function as ephemeris model.

    parameters:
      - name: custom_state_function # [py]
        type: Callable[[float], numpy.ndarray[numpy.float64[6, 1]]] # [py]
      - name: customStateFunction # [cpp]
        type: std::function< Eigen::Vector6d > # [cpp]
        description: "Function returning the state as a function of time."

      - name: frame_origin # [py]
        type: str, default="SSB" # [py]
      - name: frameOrigin # [cpp]
        type: std::string, default="SSB" # [cpp]
        description: "Origin of frame in which ephemeris data is defined."

      - name: frame_orientation # [py]
        type: str, default="ECLIPJ2000" # [py]
      - name: frameOrientation # [cpp]
        type: std::string, default="ECLIPJ2000" # [cpp]
        description: "Orientation of frame in which ephemeris data is defined."

    returns:
        type: CustomEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.CustomEphemerisSettings` class

    examples: |
      In this example, we create :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` for Earth from a custom state history function:

      .. code-block:: python # [py]
        # [py]
        # Define the custom state function for Earth # [py]
        def custom_state_function(time): # [py]
            # Compute what fraction of the year it is # [py]
            frac_year = (time - 2451545) % (365.25*24*3600) # [py]
            # Distance and velocity of the Earth w.r.t. the Sun # [py]
            AU, v_E = 1.496e11, 30e3 # [py]
            # Compute the position and velocity of the Earth in a 2D circle # [py]
            x_pos = np.sin(frac_year*np.pi) * AU # [py]
            y_pos = np.cos(frac_year*np.pi) * AU # [py]
            x_vel = np.cos(frac_year*np.pi) * v_E # [py]
            y_vel = np.sin(frac_year*np.pi) * v_E # [py]
            return [x_pos, y_pos, 0, x_vel, y_vel, 0] # [py]
        # Define the ephemeris frame # [py]
        frame_origin = "SSB" # [py]
        frame_orientation = "J2000" # [py]
        # Make the ephemeris settings # [py]
        body_settings.get("Earth").ephemeris_settings = environment_setup.ephemeris.custom( # [py]
            custom_state_function, # [py]
            frame_origin, # [py]
            frame_orientation) # [py]

      .. code-block:: cpp # [cpp]
         # [cpp] code snippet unavailable

  #######################################################################

  - name: keplerian # [py]
  - name: keplerEphemerisSettings # [cpp]
    short_summary: "Factory function for creating Keplerian ephemeris model settings."
    extended_summary: |
      Factory function for settings object, defining ephemeris model which represents an ideal Kepler orbit from the given Kepler elements.
      These are taken as the elements at the ``initial_state_epoch`` and propagated to any other time using the provided ``central_body_gravitational_parameter``.
      See `Element Types <https://docs.tudat.space/en/latest/_src_user_guide/state_propagation/environment_setup/available_state_definitions_conversions.html#element-types>`_ and the :ref:`\`\`astro\`\`` module for more details on orbital elements in tudat.

    parameters:
      - name: initial_state_in_keplerian_elements # [py]
        type: numpy.ndarray[numpy.float64[6, 1]] # [py]
      - name: initialStateInKeplerianElements # [cpp]
        type: Eigen::Vector6d # [cpp]
        description: |
          Kepler elements at epoch given by ``initial_state_epoch``. # [py]
          Kepler elements at epoch given by ``epochOfInitialState``. # [cpp]

      - name: initial_state_epoch # [py]
        type: float # [py]
      - name: epochOfInitialState # [cpp]
        type: double # [cpp]
        description: |
          Epoch at which ``initial_state_epoch`` represents the Keplerian state. # [py]
          Epoch at which ``initialStateInKeplerianElements`` represents the Keplerian state. # [cpp]

      - name: central_body_gravitational_parameter # [py]
        type: float # [py]
      - name: centralBodyGravitationalParameter # [cpp]
        type: double # [cpp]
        description: |
         Effective gravitational parameter of the central body that is used in the computations. Note that when
         the Keplerian orbit is to represent the relative state of two massive bodies, with one of these bodies as the origin
         this values should be the *sum* of the two bodies' gravitational parameters

      - name: frame_origin # [py]
        type: str, default="SSB" # [py]
      - name: referenceFrameOrigin # [cpp]
        type: std::string, default="SSB" # [cpp]
        description: "Origin of frame in which ephemeris data is defined."

      - name: frame_orientation # [py]
        type: str, default="ECLIPJ2000" # [py]
      - name: referenceFrameOrientation # [cpp]
        type: std::string, default="ECLIPJ2000" # [cpp]
        description: "Orientation of frame in which ephemeris data is defined."

      - name: root_finder_absolute_tolerance # [py]
        type: float # [py]
      - name: rootFinderAbsoluteTolerance # [cpp]
        type: double, default=200.0 * std::numeric_limits< double >::epsilon( ) # [cpp]
        description: |
          Convergence tolerance on iterative conversion from mean to eccentric anomaly;
          applies every time a cartesian state is requested from the kepler ephemeris, such as during propagation.

      - name: root_finder_maximum_number_of_iterations # [py]
        type: float # [py]
      - name: rootFinderMaximumNumberOfIterations # [cpp]
        type: double, default=200.0 * std::numeric_limits< double >::epsilon( ) # [cpp]
        description: |
          Maximum iteration on iterative conversion from mean to eccentric anomaly;
          applies every time a cartesian state is requested from the kepler ephemeris, such as during propagation.

    returns:
        type: KeplerEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.KeplerEphemerisSettings` class

    examples: |
      In this example, we create :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` for a simple, barycentric (SSB) Kepler orbit of Jupiter:

      .. code-block:: python # [py]
        # [py]
        # Define the computation of the Kepler orbit ephemeris # [py]
        initial_state_in_keplerian_elements = [100e9, 0.7, 1.0, 2.0, 2.0, 2.0] # [py]
        initial_state_epoch = 12345 # [py]
        central_body_gravitational_parameter = 1.3284e20 # (sum of Sun and Jupiter) # [py]
        # Define the ephemeris frame # [py]
        frame_origin = "SSB" # [py]
        frame_orientation = "J2000" # [py]
        # Create ephemeris settings and add to body settings of "Jupiter" # [py]
        body_settings.get( "Jupiter" ).ephemeris_settings = environment_setup.ephemeris.keplerian( # [py]
            initial_state_in_keplerian_elements, # [py]
            initial_state_epoch, # [py]
            central_body_gravitational_parameter, # [py]
            frame_origin, frame_orientation ) # [py]

      # cpp code snippet unavailable # [cpp]

  #######################################################################

  - name: keplerian_from_spice # [py]
  - name: keplerEphemerisFromSpiceSettings # [cpp]
    short_summary: "Factory function for creating Keplerian ephemeris model settings with initial state from Spice."
    extended_summary: |
      Factory function for settings object, defining ephemeris model which represents an ideal Kepler orbit from an initial state from Spice.
      The Kepler elements inferred from the initial state are propagated to any other time using the provided ``central_body_gravitational_parameter``.
      See `Element Types <https://docs.tudat.space/en/latest/_src_user_guide/state_propagation/environment_setup/available_state_definitions_conversions.html#element-types>`_ and the :ref:`\`\`astro\`\`` module for more details on orbital elements in tudat.

    parameters:
      - name: body # [py]
        type: str # [py]
      - name: body # [cpp] # (%!) suggest bodyName for consistency with cpp style and parameter of other functions
        type: std::string # [cpp]
        description: "Name of body for which to create ephemeris settings and infer initial state from Spice."

      - name: initial_state_epoch # [py]
        type: float # [py]
      - name: epochOfInitialState # [cpp]
        type: double # [cpp]
        description: |
          Epoch at which ``initial_state_epoch`` represents the Keplerian state. # [py]
          Epoch at which ``initialStateInKeplerianElements`` represents the Keplerian state. # [cpp]

      - name: central_body_gravitational_parameter # [py]
        type: float # [py]
      - name: centralBodyGravitationalParameter # [cpp]
        type: double # [cpp]
        description: "Gravitational parameter of the central body that is used in the computations."

      - name: frame_origin # [py]
        type: str, default="SSB" # [py]
      - name: referenceFrameOrigin # [cpp]
        type: std::string, default="SSB" # [cpp]
        description: "Origin of frame in which ephemeris data is defined."

      - name: frame_orientation # [py]
        type: str, default="ECLIPJ2000" # [py]
      - name: referenceFrameOrientation # [cpp]
        type: std::string, default="ECLIPJ2000" # [cpp]
        description: "Orientation of frame in which ephemeris data is defined."

      - name: root_finder_absolute_tolerance # [py]
        type: float # [py]
      - name: rootFinderAbsoluteTolerance # [cpp]
        type: double, default=200.0 * std::numeric_limits< double >::epsilon( ) # [cpp]
        description: |
          Convergence tolerance on iterative conversion from mean to eccentric anomaly;
          applies every time a cartesian state is requested from the kepler ephemeris, such as during propagation.

      - name: root_finder_maximum_number_of_iterations # [py]
        type: float # [py]
      - name: rootFinderMaximumNumberOfIterations # [cpp]
        type: double, default=200.0 * std::numeric_limits< double >::epsilon( ) # [cpp]
        description: |
          Maximum iteration on iterative conversion from mean to eccentric anomaly;
          applies every time a cartesian state is requested from the kepler ephemeris, such as during propagation.

    returns:
        type: KeplerEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.KeplerEphemerisSettings` class


    examples: |
      In this example, we create :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` for a simple, barycentric (SSB) Kepler orbit of Jupiter.
      The initial keplerian state is extracted from Spice as the state of ``body_name`` w.r.t. ``frame_origin``

      .. code-block:: python # [py]
        # [py]
        # Define the parameters for retrieval of the initial Kepler orbit elements from spice # [py]
        body_name = "Jupiter" # [py]
        initial_state_epoch = 12345 # [py]
        central_body_gravitational_parameter = 1.3284e20 # (sum of Sun and Jupiter) # [py]
        # Define the ephemeris frame # [py]
        frame_origin = "SSB" # [py]
        frame_orientation = 'J2000' # [py]
        # Make ephemeris the settings and add to body settings of "Jupiter" # [py]
        body_settings.get( "Jupiter" ).ephemeris_settings = environment_setup.ephemeris.keplerian_from_spice(  # [py]
            body_name, # [py]
            initial_state_epoch, # [py]
            central_body_gravitational_parameter, # [py]
            frame_origin, # [py]
            frame_orientation ) # [py]

      # cpp code snippet unavailable # [cpp]

      Additionally, as is the case for the :func:`~tudatpy.numerical_simulation.environment_setup.ephemeris.direct_spice`, :func:`~tudatpy.numerical_simulation.environment_setup.ephemeris.approximate_jpl_model` and :func:`~tudatpy.numerical_simulation.environment_setup.ephemeris.interpolated_spice` functions, the ephemeris model from Spice can be retrieved for some body and assigned to a custom body.

  #######################################################################

  - name: scaled_by_constant # [py]
  - name: scaledEphemerisSettings # [cpp]
    short_summary: "Factory function for creating scaled ephemeris model settings."
    extended_summary: |
      Factory function for settings object, defining ephemeris model based on an scaling of an existing ephemeris settings object.
      The user can apply a scaling factor (or an absolute value) to the resulting Cartesian states (for instance for an uncertainty analysis).

    parameters:
      - name: unscaled_ephemeris_settings # [py]
        type: EphemerisSettings # [py] # (%! correct type?)
      - name: baseSettings # [cpp]
        type: std::shared_ptr< EphemerisSettings > # [cpp]
        description: "Sets base settings of ephemeris to be scaled."

      - name: scaling_constant # [py]
        type: float # [py]
      - name: scaling # [cpp]
        type: double # [cpp]
        description: "Constant scaling factor to be applied to all elements of the Cartesian state."

      - name: is_scaling_absolute # [py]
        type: bool, default=false # [py]
      - name: isScalingAbsolute # [cpp]
        type: bool # [cpp]
        description: "Boolean indicating whether ephemeris scaling is absolute. Setting this boolean to true will add the scaling value to the state, instead of the default behaviour of multiplying the state by the scaling value."

    returns:
        type: ScaledEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.ScaledEphemerisSettings` class


    examples: |
      In this example, we create ephemeris settings for Jupiter, by scaling an existing :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettingsObject` with a constant factor:

      .. code-block:: python # [py]
         # [py]
         # define variable for scaling factor
         scaling_constant = 1.001
         # define variables containing the existing ephemeris settings
         unscaled_ephemeris_settings = body_settings.get( "Jupiter" ).ephemeris_settings
         # make new ephemeris settings
         body_settings.get( "Jupiter" ).ephemeris_settings =  environment_setup.ephemeris.scaled_by_constant(
                unscaled_ephemeris_settings, scaling_constant )
      
      In the above case, the original Jupiter ephemeris setting is taken and each state element (x,y,z position and velocity) from the original ephemeris is multiplied by a factor 1.001.


      # cpp code snippet unavailable # [cpp]

  #######################################################################

  - name: scaled_by_vector # [py]
  - name: scaledEphemerisSettings # [cpp]
    short_summary: "Factory function for creating scaled ephemeris model settings."
    extended_summary: |
      Factory function for settings object, defining ephemeris model based on an scaling of an existing ephemeris settings object.
      The user can apply a scaling factor (or an absolute value) to the resulting Cartesian states (for instance for an uncertainty analysis).

    parameters:
      - name: unscaled_ephemeris_settings # [py]
        type: EphemerisSettings # [py] # (%! correct type?)
      - name: baseSettings # [cpp]
        type: std::shared_ptr< EphemerisSettings > # [cpp]
        description: "Sets base settings of ephemeris to be scaled."

      - name: scaling_vector # [py]
        type: numpy.ndarray[numpy.float64[6, 1]] # [py]
      - name: scaling # [cpp]
        type: Eigen::Vector6d # [cpp]
        description: "Vector containing scaling factors to be applied to each element of the Cartesian state."

      - name: is_scaling_absolute # [py]
        type: bool, default=false # [py]
      - name: isScalingAbsolute # [cpp]
        type: bool # [cpp]
        description: "Boolean indicating whether ephemeris scaling is absolute. Setting this boolean to true will add the scaling value to the state, instead of the default behaviour of multiplying the state by the scaling value."

    returns:
        type: ScaledEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.ScaledEphemerisSettings` class
       
        
    examples: |
      In this example, we create ephemeris settings for Jupiter, by scaling an existing :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettingsObject` with the constant elements of a vector:

      .. code-block:: python # [py]
        # [py]
        # Define the scaling vector # [py]
        scaling_vector = [1.01, 0.99, 1, 1, 1, 0] # [py]
        # Extract the unscaled ephemeris settings from Jupiter # [py]
        unscaled_ephemeris_settings = body_settings.get( "Jupiter" ).ephemeris_settings # [py]
        # Create the scaled ephemeris settings and apply to the body "Jupiter" # [py]
        body_settings.get( "Jupiter" ).ephemeris_settings =  environment_setup.ephemeris.scaled_by_vector( # [py]
            unscaled_ephemeris_settings, # [py]
            scaling_vector) # [py]
      
      In the above case, the original Jupiter ephemeris setting is taken and each state element (x,y,z position and velocity) from the original ephemeris is multiplied by the corresponding scaling factor in ``scaling_vector``.

      # cpp code snippet unavailable # [cpp]
      
  #######################################################################

  - name: scaled_by_vector_function # [py]
  - name: scaledEphemerisSettings # [cpp]
    short_summary: "Factory function for creating scaled ephemeris model settings."
    extended_summary: |
      Factory function for settings object, defining ephemeris model based on an scaling of an existing ephemeris settings object.
      The user can apply a scaling factor (or an absolute value) to the resulting Cartesian states (for instance for an uncertainty analysis).

    parameters:
      - name: unscaled_ephemeris_settings # [py]
        type: EphemerisSettings # [py] # (%! correct type?)
      - name: baseSettings # [cpp]
        type: std::shared_ptr< EphemerisSettings > # [cpp]
        description: "Sets base settings of ephemeris to be scaled."

      - name: scaling_vector_function # [py]
        type: callable[[float], numpy.ndarray[numpy.float64[6, 1]]] # [py]
      - name: scaling # [cpp]
        type: std::function< Eigen::Vector6d( const double ) > # [cpp]
        description: "Function returning a vector with the scaling factors to be applied to each element of the Cartesian state."

      - name: is_scaling_absolute # [py]
        type: bool, default=false # [py]
      - name: isScalingAbsolute # [cpp]
        type: bool # [cpp]
        description: "Boolean indicating whether ephemeris scaling is absolute. Setting this boolean to true will add the scaling value to the state, instead of the default behaviour of multiplying the state by the scaling value."

    returns:
        type: ScaledEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.ScaledEphemerisSettings` class

    examples: |
      In this example, we create ephemeris settings for Jupiter, by scaling an existing :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` object with factors from a custom function:

      .. code-block:: python # [py]
        # [py]
        # Define the scaling vector function # [py]
        def scaling_vector_function(time): # [py]
            # Add a wobble in the x and y coordinates # [py]
            wobble = 1 + 0.1 * np.cos(time/50) # [py]
            return [wobble, wobble, 1, 1, 1, 1] # [py]
        # Extract the existing unscaled ephemeris settings # [py]
        unscaled_ephemeris_settings = body_settings.get( "Jupiter" ).ephemeris_settings # [py]
        # Create the scaled ephemeris settings and apply to the body "Jupiter" # [py]
        body_settings.get( "Jupiter" ).ephemeris_settings =  environment_setup.ephemeris.scaled_by_vector_function( # [py]
            unscaled_ephemeris_settings, # [py]
            scaling_vector_function ) # [py]

      In the above case, the original Jupiter ephemeris setting is taken and each state element (x,y,z position and velocity) from the original ephemeris is multiplied by the corresponding scaling factor in the vector returned by ``vector_scaling_function``.

      # cpp code snippet unavailable # [cpp]

  #######################################################################

  - name: tabulated # [py]
  - name: tabulatedEphemerisSettings # [cpp]
    short_summary: "Factory function for creating ephemeris model settings from tabulated data."
    extended_summary: |
      Factory function for settings object, defining ephemeris model to be created from tabulated data.
      Currently the data that is provided gets interpolated by a 6th order Lagrange interpolator (hardcoded).
      At the edges of the interpolation interval a cubic spline interpolator is used to suppress the influence of Runge's phenomenon.

    parameters:
      - name: body_state_history # [py]
        type: dict # [py]
        description: Dictionary of the discrete state history data from which ephemeris is to be created. Keys representing the time (float) and values representing Cartesian states (numpy.ndarray). # [py]
      - name: bodyStateHistory # [cpp]
        type: std::map< double, Eigen::Vector6d > # [cpp]
        description: Data map defining discrete data from which an ephemeris is to be created. Keys representing the time (double) and values representing Cartesian states (Eigen::Vector6d). # [cpp]

      - name: frame_origin # [py]
        type: str, default="SSB" # [py]
      - name: frameOrigin # [cpp]
        type: std::string, default="SSB" # [cpp]
        description: "Origin of frame in which ephemeris data is defined."

      - name: frame_orientation # [py]
        type: str, default="ECLIPJ2000" # [py]
      - name: frameOrientation # [cpp]
        type: std::string, default="ECLIPJ2000" # [cpp]
        description: "Orientation of frame in which ephemeris data is defined."

    returns:
        type: TabulatedEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.TabulatedEphemerisSettings` class


    examples: |
      In this example, we create :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` for Jupiter from tabulated state history data:

      .. code-block:: python # [py]
        # [py]
        # Define the Dict containing Jupiter's tabulated state history # [py]
        body_state_history = { # [py]
            0: [7.4713e11, 0, 0, 13.5e3, 0, 0], # [py]
            1000: [7.4711e11, 5e9, 0, 13.4998e3, 75, 0], # [py]
            2150: [7.4671e11, 2.5e10, 0, 13.498e3, 200, 0], # [py]
            # ... truncated # [py]
            15650: [7.3899e11, 1.1e11, 0, 13.416e3, 1.5e3, 0] # [py]
        } # [py]
        # Define the ephemeris frame # [py]
        frame_origin = "SSB" # [py]
        frame_orientation = "J2000" # [py]
        # Create the tabulated ephemeris settings and add them to the body "Jupiter" # [py]
        body_settings.get( "Jupiter" ).ephemeris_settings = environment_setup.ephemeris.tabulated( body_state_history, # [py]
            frame_origin, # [py]
            frame_orientation ) # [py]

      # cpp code snippet unavailable # [cpp]

  #######################################################################
  
  - name: tabulated_from_existing # [py]
    short_summary: "Factory function for creating tabulated ephemeris model settings from existing ephemeris."
    extended_summary: |
      Factory function for creating tabulated ephemeris model settings from existing ephemeris.
      The ephemeris that is provided gets tabulated in a given time frame, for a given time step.
      When called, this tabulated ephemeris will use interpolation, when needed, from the specified interpolator.

      .. note:: Creating tabulated ephemeris from existing ephemeris can for instance be used when combined with estimation.
                This is because estimation needs the ephemeris to be tabulated to work.

    parameters:
      - name: ephemeris_settings # [py]
        type: tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings # [py]
        description: Existing ephemeris settings that have to be tabulated. # [py]

      - name: start_time # [py]
        type: float # [py]
        description: Initial time for which to create the tabulated ephemeris.

      - name: end_time # [py]
        type: float # [py]
        description: Final time for which to create the tabulated ephemeris.

      - name: time_step # [py]
        type: float # [py]
        description: Time step to use to tabulate the existing ephemeris.

      - name: interpolator_settings # [py]
        type: tudatpy.math.interpolators.InterpolatorSettings, default=tudatpy.math.interpolators.lagrange_interpolation(8) # [py]
        description: Interpolator settings to use when interpolating between two tabulated ephemeris.

    returns:
        type: TabulatedEphemerisSettings
        description: Instance of the :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` derived :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.TabulatedEphemerisSettings` class


    examples: |
      In this example, we create :class:`~tudatpy.numerical_simulation.environment_setup.ephemeris.EphemerisSettings` for Io.
      First, we extract the existing ephemeris. Then, we define new tabulated ephemeris settings, from the original settings.

      .. code-block:: python # [py]
        # [py]
        # Get the original ephemeris settings # [py]
        original_io_ephemeris_settings = body_settings.get( "Io" ).ephemeris_settings # [py]
        # Apply new tabulated ephemeris settings # [py]
        body_settings.get( "Io" ).ephemeris_settings =  environment_setup.ephemeris.tabulated_from_existing( # [py]
          original_io_ephemeris_settings, # [py]
          initial_time, # [py]
          final_time, # [py]
          time_step ) # [py]

  #######################################################################
